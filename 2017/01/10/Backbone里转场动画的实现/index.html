<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Backbone里转场动画的实现 · Hexo</title><meta name="description" content="Backbone里转场动画的实现 - alisec-ued"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://alisec-ued.github.io/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/alisec-ued" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Backbone里转场动画的实现</h1><div class="post-info">Jan 10, 2017</div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做消费者安全中心这个项目的时候，有个想法是在页面切换的时候做些转场动画，使得更像原生体验。这个项目是基于Backbone来做的，熟悉Backbone的都知道，框架本身没有提供什么转场动画，市面上也没看到有人分享过什么插件实现这个效果，后来和小伙伴们研究出一个实现办法，分享出来给大家。</p>
<a id="more"></a>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>最终实现效果如下</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e7aaef8307c193d51484e332e3f8543e.gif" alt="fdsfdsafa.gif"></p>
<p>可在手机淘宝<code>“我的淘宝-&gt;设置-&gt;账号与安全-&gt;安全中心”</code>打开或使用手机淘宝扫下面二维码</p>
<p><img width="200" height="200" src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/f12598816733997dad543a95b2cfb6d9.png"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要想实现转场，首先考虑在哪个时机进行？一开始我想到肯定是在View切换的时候，我来看看路由如何控制View切换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Backbone.Router.extend(&#123;</div><div class="line">  <span class="attr">currentView</span>: <span class="literal">null</span>,</div><div class="line">  <span class="attr">routes</span>: &#123;</div><div class="line">    <span class="string">''</span>: <span class="string">'home'</span>,</div><div class="line">    <span class="string">'list'</span>: <span class="string">'list'</span></div><div class="line">  &#125;,</div><div class="line">  changeView(view) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentView !== <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.currentView.undelegateEvents();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.currentView = view;</div><div class="line">    <span class="keyword">this</span>.currentView.render();</div><div class="line">  &#125;,</div><div class="line">  home() &#123;</div><div class="line">    <span class="keyword">const</span> homeView = <span class="keyword">new</span> HomeView();</div><div class="line">    <span class="keyword">this</span>.changeView(homeView);</div><div class="line">  &#125;,</div><div class="line">  list() &#123;</div><div class="line">    <span class="keyword">const</span> listView = <span class="keyword">new</span> ListView();</div><div class="line">    <span class="keyword">this</span>.changeView(listView);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一开始我是这样想的，<code>changeView</code>函数里有<code>view</code>和<code>currentView</code>，<code>currentView</code>是当前页面，<code>view</code>是即将出来的页面，有了这两个元素，进行转场岂不是太简单了！于是想拿到这两个元素，打印出来看看</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/aa90bc3c9c0917e645bb7581a8f9a4a9.png" alt="粘贴图片(3).png"></p>
<p>发现<code>view</code>和<code>currentView</code>的 <code>el</code> 属性都是指向<code>app</code>，也就是页面的根元素。这时我懂了，Backbone所有<code>View</code>的共用一个<code>div</code>，只要有一个<code>View</code>执行<code>render</code>，那么根元素里面的内容就被替换，所以<code>同一时刻只有一个View的内容存在</code>。</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b399e143937c50e0c6c9dfe156d28359.png" alt="粘贴图片(8).png"></p>
<p>那么解决方案就是，我们需要保证在转场过程中两个View的内容同时存在，转场结束后把上一个View的内容清空。</p>
<p>Backbone.View里有个 <code>el</code> 属性，就是设置页面的<code>根元素</code>，我们要保证转场过程中两个View的内容同时存在，那一个根元素是不够的，需要两个！</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/dfbadfc5bd8becac90a64c3b77c87c2f.png" alt="粘贴图片(8).png"></p>
<p>所以我们在View的构造函数里动态选页面择根元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(options) &#123;</div><div class="line">  <span class="comment">// 为了配合转场动画，view创建的时候会动态选择根元素</span></div><div class="line">  <span class="keyword">this</span>.el = <span class="keyword">this</span>.selectViewRoot();</div><div class="line">  $(<span class="keyword">this</span>.el).removeClass(<span class="string">'app-disabled'</span>).addClass(<span class="string">'app-active'</span>);</div><div class="line">&#125;,</div><div class="line">selectViewRoot() &#123;</div><div class="line">  <span class="keyword">if</span> (!$(<span class="string">'.app-content'</span>).hasClass(<span class="string">'app-active'</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'.app-content'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!$(<span class="string">'.app-content-back'</span>).hasClass(<span class="string">'app-active'</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'.app-content-back'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 <code>app-content</code> 和 <code>app-content-back</code> 是两个页面根元素，当一个View创建的时候动态选择其中一个。比如View1当前使用的根元素是app-content，从View1切换到View2的时候，View2则使用app-content-back，View2切换到View3的时候，View3则会使用app-content，如此类推。</p>
<p>这时，我们就可以保证在View切换的时候，两个View的内容是同时存在的。那在这个时候进行动画太简单了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">changeView(view) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.currentView !== <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.currentView.undelegateEvents();</div><div class="line">    Scene.changeView(<span class="keyword">this</span>.currentView.$el, view.$el);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.currentView = view;</div><div class="line">  <span class="keyword">this</span>.currentView.render();</div><div class="line">&#125;,</div><div class="line"><span class="comment">// CSS3动画转场，这里可自由选择</span></div><div class="line">Scene.changeView(currentView, view) &#123;</div><div class="line">  <span class="keyword">if</span> (appback) &#123;</div><div class="line">    <span class="comment">// 页面返回 转场 </span></div><div class="line">    currentView.addClass(<span class="string">'slideOutRight'</span>);</div><div class="line">    view.addClass(<span class="string">'slideInLeft'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 页面进入 转场</span></div><div class="line">    currentView.addClass(<span class="string">'slideOutLeft'</span>);</div><div class="line">    view.addClass(<span class="string">'slideInRight'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>什么时候清空掉上一个View的内容呢？那就是转场动画结束后。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'.app-content'</span>).on(<span class="string">'webkitAnimationEnd'</span>, () =&gt; &#123;</div><div class="line">  <span class="comment">// 清除动画</span></div><div class="line">  $(<span class="string">'.app-content'</span>).removeClass(...);</div><div class="line">  <span class="comment">// 清除上一个View</span></div><div class="line">  <span class="keyword">if</span> ($(<span class="string">'.app-content'</span>).hasClass(<span class="string">'app-disabled'</span>)) &#123;</div><div class="line">    $(<span class="string">'.app-content'</span>).html(<span class="string">''</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>到这里，转场动画已经全部实现了，上面贴的只是核心代码，详细可以自己体会。下面一张图展示这个流程。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/375cbda7f2b92e31ef7da6d4ba871278.png" alt="粘贴图片(11).png"></p>
<p>有人会问，这个每个人都需要实现一遍吗，当然不是，这些逻辑都是与业务逻辑独立的，可以在框架层面上作封装，只需要扩展Backbone的View和Router即可，使用者完全无感知。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>最近看了React router，能够提供接入中间件实现转场，可见最根本的办法就是改造Backbone的Router和View，不要只限制每个View公用一个根元素，同时暴露页面进入前、页面进入后的回调给使用者，这才能进行更好的扩展。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2017/01/03/Flex布局原理介绍/" class="next">NEXT</a></div><style>.ds-powered-by, .ds-comments-tab-weibo {
    display: none !important;
}</style><div data-thread-key="2017/01/10/Backbone里转场动画的实现/" data-title="Backbone里转场动画的实现" data-url="https://alisec-ued.github.io/2017/01/10/Backbone里转场动画的实现/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"alisec-ued"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 - 2017 <a href="https://alisec-ued.github.io">alisec-ued</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>var _hmt = _hmt || []; (function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?f356a2d337ba7259fc3c8223ad3deeac";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>