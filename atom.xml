<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://alisec-ued.github.io/"/>
  <updated>2017-01-10T03:10:17.000Z</updated>
  <id>https://alisec-ued.github.io/</id>
  
  <author>
    <name>alisec-ued</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Backbone里转场动画的实现</title>
    <link href="https://alisec-ued.github.io/2017/01/10/Backbone%E9%87%8C%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://alisec-ued.github.io/2017/01/10/Backbone里转场动画的实现/</id>
    <published>2017-01-10T03:06:36.000Z</published>
    <updated>2017-01-10T03:10:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做消费者安全中心这个项目的时候，有个想法是在页面切换的时候做些转场动画，使得更像原生体验。这个项目是基于Backbone来做的，熟悉Backbone的都知道，框架本身没有提供什么转场动画，市面上也没看到有人分享过什么插件实现这个效果，后来和小伙伴们研究出一个实现办法，分享出来给大家。</p>
<a id="more"></a>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>最终实现效果如下</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e7aaef8307c193d51484e332e3f8543e.gif" alt="fdsfdsafa.gif"></p>
<p>可在手机淘宝<code>“我的淘宝-&gt;设置-&gt;账号与安全-&gt;安全中心”</code>打开或使用手机淘宝扫下面二维码</p>
<p><img width="200" height="200" src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/f12598816733997dad543a95b2cfb6d9.png"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要想实现转场，首先考虑在哪个时机进行？一开始我想到肯定是在View切换的时候，我来看看路由如何控制View切换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Backbone.Router.extend(&#123;</div><div class="line">  <span class="attr">currentView</span>: <span class="literal">null</span>,</div><div class="line">  <span class="attr">routes</span>: &#123;</div><div class="line">    <span class="string">''</span>: <span class="string">'home'</span>,</div><div class="line">    <span class="string">'list'</span>: <span class="string">'list'</span></div><div class="line">  &#125;,</div><div class="line">  changeView(view) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentView !== <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.currentView.undelegateEvents();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.currentView = view;</div><div class="line">    <span class="keyword">this</span>.currentView.render();</div><div class="line">  &#125;,</div><div class="line">  home() &#123;</div><div class="line">    <span class="keyword">const</span> homeView = <span class="keyword">new</span> HomeView();</div><div class="line">    <span class="keyword">this</span>.changeView(homeView);</div><div class="line">  &#125;,</div><div class="line">  list() &#123;</div><div class="line">    <span class="keyword">const</span> listView = <span class="keyword">new</span> ListView();</div><div class="line">    <span class="keyword">this</span>.changeView(listView);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一开始我是这样想的，<code>changeView</code>函数里有<code>view</code>和<code>currentView</code>，<code>currentView</code>是当前页面，<code>view</code>是即将出来的页面，有了这两个元素，进行转场岂不是太简单了！于是想拿到这两个元素，打印出来看看</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/aa90bc3c9c0917e645bb7581a8f9a4a9.png" alt="粘贴图片(3).png"></p>
<p>发现<code>view</code>和<code>currentView</code>的 <code>el</code> 属性都是指向<code>app</code>，也就是页面的根元素。这时我懂了，Backbone所有<code>View</code>的共用一个<code>div</code>，只要有一个<code>View</code>执行<code>render</code>，那么根元素里面的内容就被替换，所以<code>同一时刻只有一个View的内容存在</code>。</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b399e143937c50e0c6c9dfe156d28359.png" alt="粘贴图片(8).png"></p>
<p>那么解决方案就是，我们需要保证在转场过程中两个View的内容同时存在，转场结束后把上一个View的内容清空。</p>
<p>Backbone.View里有个 <code>el</code> 属性，就是设置页面的<code>根元素</code>，我们要保证转场过程中两个View的内容同时存在，那一个根元素是不够的，需要两个！</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/dfbadfc5bd8becac90a64c3b77c87c2f.png" alt="粘贴图片(8).png"></p>
<p>所以我们在View的构造函数里动态选页面择根元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(options) &#123;</div><div class="line">  <span class="comment">// 为了配合转场动画，view创建的时候会动态选择根元素</span></div><div class="line">  <span class="keyword">this</span>.el = <span class="keyword">this</span>.selectViewRoot();</div><div class="line">  $(<span class="keyword">this</span>.el).removeClass(<span class="string">'app-disabled'</span>).addClass(<span class="string">'app-active'</span>);</div><div class="line">&#125;,</div><div class="line">selectViewRoot() &#123;</div><div class="line">  <span class="keyword">if</span> (!$(<span class="string">'.app-content'</span>).hasClass(<span class="string">'app-active'</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'.app-content'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!$(<span class="string">'.app-content-back'</span>).hasClass(<span class="string">'app-active'</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'.app-content-back'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 <code>app-content</code> 和 <code>app-content-back</code> 是两个页面根元素，当一个View创建的时候动态选择其中一个。比如View1当前使用的根元素是app-content，从View1切换到View2的时候，View2则使用app-content-back，View2切换到View3的时候，View3则会使用app-content，如此类推。</p>
<p>这时，我们就可以保证在View切换的时候，两个View的内容是同时存在的。那在这个时候进行动画太简单了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">changeView(view) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.currentView !== <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.currentView.undelegateEvents();</div><div class="line">    Scene.changeView(<span class="keyword">this</span>.currentView.$el, view.$el);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.currentView = view;</div><div class="line">  <span class="keyword">this</span>.currentView.render();</div><div class="line">&#125;,</div><div class="line"><span class="comment">// CSS3动画转场，这里可自由选择</span></div><div class="line">Scene.changeView(currentView, view) &#123;</div><div class="line">  <span class="keyword">if</span> (appback) &#123;</div><div class="line">    <span class="comment">// 页面返回 转场 </span></div><div class="line">    currentView.addClass(<span class="string">'slideOutRight'</span>);</div><div class="line">    view.addClass(<span class="string">'slideInLeft'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 页面进入 转场</span></div><div class="line">    currentView.addClass(<span class="string">'slideOutLeft'</span>);</div><div class="line">    view.addClass(<span class="string">'slideInRight'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>什么时候清空掉上一个View的内容呢？那就是转场动画结束后。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'.app-content'</span>).on(<span class="string">'webkitAnimationEnd'</span>, () =&gt; &#123;</div><div class="line">  <span class="comment">// 清除动画</span></div><div class="line">  $(<span class="string">'.app-content'</span>).removeClass(...);</div><div class="line">  <span class="comment">// 清除上一个View</span></div><div class="line">  <span class="keyword">if</span> ($(<span class="string">'.app-content'</span>).hasClass(<span class="string">'app-disabled'</span>)) &#123;</div><div class="line">    $(<span class="string">'.app-content'</span>).html(<span class="string">''</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>到这里，转场动画已经全部实现了，上面贴的只是核心代码，详细可以自己体会。下面一张图展示这个流程。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/375cbda7f2b92e31ef7da6d4ba871278.png" alt="粘贴图片(11).png"></p>
<p>有人会问，这个每个人都需要实现一遍吗，当然不是，这些逻辑都是与业务逻辑独立的，可以在框架层面上作封装，只需要扩展Backbone的View和Router即可，使用者完全无感知。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>最近看了React router，能够提供接入中间件实现转场，可见最根本的办法就是改造Backbone的Router和View，不要只限制每个View公用一个根元素，同时暴露页面进入前、页面进入后的回调给使用者，这才能进行更好的扩展。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在做消费者安全中心这个项目的时候，有个想法是在页面切换的时候做些转场动画，使得更像原生体验。这个项目是基于Backbone来做的，熟悉Backbone的都知道，框架本身没有提供什么转场动画，市面上也没看到有人分享过什么插件实现这个效果，后来和小伙伴们研究出一个实现办法，分享出来给大家。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://alisec-ued.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局原理介绍</title>
    <link href="https://alisec-ued.github.io/2017/01/03/Flex%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/"/>
    <id>https://alisec-ued.github.io/2017/01/03/Flex布局原理介绍/</id>
    <published>2017-01-03T09:30:03.000Z</published>
    <updated>2017-01-03T10:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>CSS3中的 Flexible Box，或者叫flexbox，是用于排列元素的一种布局模式。</p>
<p>顾名思义，弹性布局中的元素是有伸展和收缩自身的能力的。 相比于原来的布局方式，如float、position，根据盒子模型，就可以计算出元素的展示尺寸（长宽非百分比），除非溢出，否则不依赖于父容器的大小。</p>
<p>而弹性布局中元素的大小是高度依赖父容器的大小的。因为，<strong>它所具有的“伸缩性”，目标就是为了撑满父元素。</strong>当然这是在任其“野蛮生长”的情况下，你也可以通过相关css属性控制其是否撑满、撑满什么轴。</p>
<p>弹性布局是一种全新的思维方式，让很多实现复杂的问题有了更好的理解方式（如垂直居中）。只需要给<strong>直接</strong>父容器设置为<code>display: flex;</code> ，duang~ 子元素就默认具有了<strong>可收缩性</strong>。</p>
<a id="more"></a>
<p>Flex的语法规范也曾经有很多版本：  </p>
<ul>
<li>最新版本是<code>display: flex;</code></li>
<li>中间版本是<code>display: flexbox</code>;</li>
<li>最老版本<code>display: box</code>;</li>
</ul>
<p>本篇文章侧重于flex难理解的点，适合于已经了解过<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">flex的api</a>的童鞋观看。（api其实就下图这么多，橙色是常用的）</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a493540fa5ba58ce63a43bc84e13a2cd.png" alt="screenshot.png"></p>
<h2 id="为何要引入主轴、交叉轴、轴线的概念"><a href="#为何要引入主轴、交叉轴、轴线的概念" class="headerlink" title="为何要引入主轴、交叉轴、轴线的概念"></a>为何要引入主轴、交叉轴、轴线的概念</h2><p>我们首先看一下，CSS布局的发展历程：</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a7081844485fdb0e22010e6f7143895a.png" alt="screenshot.png"></p>
<p>最开始使用的布局方式是table布局。还记得我在2010年大一的时候，使用的就是这种布局，那时候div+css还没有成为主流，至少还没覆盖到我的学校。</p>
<p>table布局的特点是非常好理解和上手，用过excel的都知道怎么组织代码：将网页划分为一个大的表格，将元素一个个填到表格中，如果表格不够大就合并单元格。但是这种布局的缺点是过于规整，只能适用于简单、规整的网页。且网站的布局严重依赖于html，很多冗余的布局html代码。</p>
<p>到了2011年大二，我换了一个校区，也换了个地方做网页，部门负责人跟我说：“现在大家都用div+css了，来给你上堂课。”<br>我心里一懵，就这么不小心经历了“历史的变迁”。入门难了，新增了相对定位和绝对定位的概念，但是却能够应付复杂一点的网页了。</p>
<p>接着因为“文字环绕”的需求，出现了浮动（float）布局。虽然有很多副作用，但是人们更喜欢它的价值，如今使用的频率也很高，比如bootstrap的栅格系统。</p>
<p>CSS3新增了Flexbox。虽然前几种布局也可以实现垂直居中、等分、栅格等需求，但是往往需要脑袋转好几个弯，最后也不一定可行。而flex则使用了更直接明了的思路来实现这些布局。</p>
<p>总的来说，虽然布局方式变多了，<strong>但并不是前者取代后者</strong>。直到现在，考虑到浏览器兼容性等问题，一种布局都有自己独一无二的使用价值。</p>
<p>言归正传，翻开flex的入门教程，首先映入眼帘且比较难懂的就是主轴和交叉轴（对，就是下面这张图），这是前几种布局方式都没有的。</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/d15ca4443cf1f99ad2b961c3de58dcc4.png" alt="screenshot.png"></p>
<p>前几种布局都可以按照人类书写的方式理解：“从左到右写，写不下就往下换行”。</p>
<p>但是flex特点是可以重新定义这种“书写方式”，你还可以从下到上写、从右到左写（见flex-direction属性），换行也可以从两个相反的方向换行（见flex-wrap属性）。所以引入了这个几个概念方便理解。</p>
<p>如果你只是简单的使用，其实只用得到默认值，个人认为可以不用过于深究主轴和交叉轴。</p>
<p>那么，到底这些轴的概念怎么就帮助我们理解了？</p>
<p>首先你可以先去温习一下<a href="http://codepen.io/enxaneta/full/adLPwv/" target="_blank" rel="external">flex的api</a>。</p>
<p>为了帮助理解，以类比的方式类比人类书写的方式，浏览器“书写”的方向为主轴方向，浏览器“换行的方向”为交叉轴方向，每行就是一条轴线。</p>
<p>更正式一点的说法是，浏览器的布局方式是：</p>
<p><strong>沿着主轴的方向依次排列，如果要换行，则沿着交叉轴的方向进行换行，每行代表一条轴线。</strong></p>
<p>细心的同学应该发现了，“依次”其实也不是“依次”，我们可以使用子元素的order属性对元素进行重新排序。由此可见，flex给子元素提供了很大的灵活性，但本篇文章只使用order的默认值。</p>
<p>主轴、交叉轴可以帮助我们理解这些概念：</p>
<ul>
<li><p>重新定义浏览器“书写方式”。</p>
<p> <code>flex-direction</code> 改变主轴方向；</p>
<p> <code>flex-wrap</code> 改变交叉轴方向</p>
<p> 如下图，主轴和交叉轴的排列组合有4*2 =8 种。</p>
<p> <img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/239feda71c5e515840a570c26c012c2b.png" alt="screenshot.png"></p>
</li>
</ul>
<p>   比如，可以像写对联一样，从上到下竖着书写，从右到左换行。</p>
<p>   （2017新年快乐~）</p>
<p>   <img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/c8a2a5bf0b0a5192cc1571f2179a4f53.png" alt="Bitmap.png"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">	<span class="attribute">flex-direction</span>: column;</div><div class="line">	<span class="attribute">flex-wrap</span>: wrap-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure> 
<p>   为了方便表达，本篇文章都使用默认的轴方向。</p>
<ul>
<li><p>轴上的元素的排列方式(justify-content, align-items)。  </p>
<ul>
<li>justify-content 定义了元素在主轴轴上如何对齐；   </li>
<li><p>align-items 定义了元素在交叉轴上如何对齐。   </p>
<p>因为轴都有方向，因此也有轴起点和轴终点：  </p>
</li>
<li><p>flex-start: 对齐轴起点;    </p>
</li>
<li>flex-end: 对齐轴终点;  </li>
<li>center：在轴线上居中;  </li>
<li>space-between：两端不带间距的轴线两端对齐;  </li>
<li>space-around: 两端带间距的轴线两端对齐, 且每个子元素之间的间距相同（假设为x）。两端元素离父元素间距为（x/2）。 <strong>注意这个间距既不是margin也不是padding，盒子模型来计算展示方式已经不适用了。</strong>  </li>
<li>baseline：交叉轴特有，基线对齐。   </li>
<li>stretch：交叉轴特有，有占满整个主轴高度的意向。当设置了子元素高度为非auto时不生效。 </li>
</ul>
</li>
<li><p>多根轴线时，轴线之间的排列方式(align-content)。<br>  align-content的参照轴是交叉轴。其属性也和上面的justify-content、align-items大同小异：flex-start、flex-end、center、space-between、space-around、stretch。不多做解释。</p>
</li>
</ul>
<h2 id="元素宽度如何伸缩"><a href="#元素宽度如何伸缩" class="headerlink" title="元素宽度如何伸缩"></a>元素宽度如何伸缩</h2><p>能决定元素展示宽度的属性有：<code>flex-shrink，flex-grow，flex-basis，width，min-width</code></p>
<p>因为flex为前三个属性的缩写方式，所以常用写法是<code>flex-shrink，flex-grow，flex-basis</code>统一用<code>flex</code>设置。</p>
<p>常见的flex设置：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>样式</th>
<th>flex-grow</th>
<th>flex-shrink</th>
<th>flex-basis</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>flex默认值</td>
<td>0</td>
<td>1</td>
<td>auto</td>
</tr>
<tr>
<td>②</td>
<td>flex: 1;</td>
<td>1</td>
<td>1</td>
<td>0%</td>
</tr>
<tr>
<td>③</td>
<td>flex: auto;</td>
<td>1</td>
<td>1</td>
<td>auto</td>
</tr>
<tr>
<td>④</td>
<td>flex: none;</td>
<td>0</td>
<td>0</td>
<td>auto</td>
</tr>
</tbody>
</table>
<p>那么，flex-grow和flex-shrink的值会对元素造成什么影响呢？</p>
<p>如下图所示，当元素允许缩小时，最终展示的效果会是正好撑满主轴。</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b7150d5b04ac74a7f26ad44e9c5d6cd8.png" alt="screenshot.png"></p>
<p>在父容器中有三个元素A1,A2,A3,他们都有一个<strong>初始宽度</strong>（比如设置了width且flex-basis不为0%）。初始宽度在下一小节会详细讲。</p>
<p>如果按照初始宽度放入普通父容器中，那么他们会溢出<strong>x</strong>个像素（见初始尺寸行）。</p>
<p>当父元素<code>display: flex;</code>， </p>
<p>且A1<code>flex-shrink:1</code>，A2<code>flex-shrink:1</code>，A3<code>flex-shrink:1</code>时，</p>
<p>A1、A2、A3都具有可收缩的特性。</p>
<p>flex-shrink的值表示需要收缩的宽度占总溢出宽度的比例，因此展示尺寸这么算：</p>
<ol>
<li><p>将x平均分为(1+1+2) = 4份，每份宽度为<strong>i = x/4</strong></p>
</li>
<li><p>A1的展示尺寸为：A1默认宽度 - i × 1；</p>
<p>A2的展示尺寸为：A1默认宽度 - i × 1；</p>
<p>A3的展示尺寸为：A1默认宽度 - i × 2；</p>
</li>
</ol>
<p>还是很好理解的吧。同理，当元素不够撑满父元素时，需要伸展的宽度也是按照这种方式计算的。只是比例基数变成了剩余空间的宽度。</p>
<p>如果你希望元素不能伸缩，那么需要设置相应的属性为0。</p>
<p>如: <code>flex-shrink: 0</code>。</p>
<h2 id="flex-basis和width的关系"><a href="#flex-basis和width的关系" class="headerlink" title="flex-basis和width的关系"></a>flex-basis和width的关系</h2><p>flex-basis 用于计算上一小节中元素的“初始宽度”。</p>
<ul>
<li>flex-basis为auto时, 初始宽度为元素内容大小或者设置的宽度值（盒子模型中的占用宽度）。</li>
<li>flex-basis为像素值时，初始宽度为flex-basis的值。</li>
<li>flex-basis为百分比时，初始宽度为占父容器的比例。</li>
<li>flex-basis为0或0%时，初始宽度为0。</li>
</ul>
<p>虽然flex-basis的优先级大于width，但是<strong>最后计算的展示尺寸受限于min-width或者max-width</strong>。</p>
<p>比如，元素A算出来的展示宽度为100px，但是它有个css属性<code>min-width: 200px;</code>, 那么最后的展示宽度仍然为200px。但是计算的初始尺寸仍然是由flex-basis决定。  </p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>从<a href="http://caniuse.com/#search=flex%20box" target="_blank" rel="external">caniuse</a>上可以查到，通过加上各种前缀，flex可以兼容到ie10以及以上。</p>
<p>16年年初在实际使用过程中，发现UC的支持性很不好。这次又重新试了一次，新版的UC也能很好的支持flex了。看来flex正在慢慢占领移动端。</p>
<h2 id="几个案例"><a href="#几个案例" class="headerlink" title="几个案例"></a>几个案例</h2><p>通过上面几小节的描述，可以发现flex用了一种全新的思路来布局。<br>列出几个常见的案例，以下案例的代码统一在<a href="http://codepen.io/cheer/pen/dOmpXv" target="_blank" rel="external">我的codepen</a>可查看。</p>
<p>1.垂直居中  </p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e03f10a5f35fe203fb877eaa4b33b993.png" alt="screenshot.png">  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">	<span class="attribute">display</span>: inline-flex;</div><div class="line">	<span class="attribute">align-items</span>: center;</div><div class="line">	<span class="attribute">justify-content</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure> 
<p>2.一侧固定，一侧自适应   </p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/157c8233a8290a330e20900974a8c92c.png" alt="screenshot.png">  </p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">	<span class="attribute">display</span>: flex;</div><div class="line">	<span class="selector-class">.sidebar</span> &#123;</div><div class="line">		<span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="selector-class">.content</span> &#123;</div><div class="line">		<span class="attribute">flex</span>: <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure> 
<p>3.多列等高</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/8bc2041ba11386c873fe8f401a56244b.png" alt="screenshot.png"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">	<span class="attribute">display</span>: flex;</div><div class="line">	<span class="attribute">flex-wrap</span>: wrap;</div><div class="line">	<span class="attribute">justify-content</span>: space-between;</div><div class="line">	<span class="attribute">align-content</span>: stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure> 
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>flex布局是围绕父元素和轴来进行布局的。这种全新的思路巧妙地只需要简单几行代码就可以实现曾经头疼的效果，其思路的建立过程非常值得借鉴。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;CSS3中的 Flexible Box，或者叫flexbox，是用于排列元素的一种布局模式。&lt;/p&gt;
&lt;p&gt;顾名思义，弹性布局中的元素是有伸展和收缩自身的能力的。 相比于原来的布局方式，如float、position，根据盒子模型，就可以计算出元素的展示尺寸（长宽非百分比），除非溢出，否则不依赖于父容器的大小。&lt;/p&gt;
&lt;p&gt;而弹性布局中元素的大小是高度依赖父容器的大小的。因为，&lt;strong&gt;它所具有的“伸缩性”，目标就是为了撑满父元素。&lt;/strong&gt;当然这是在任其“野蛮生长”的情况下，你也可以通过相关css属性控制其是否撑满、撑满什么轴。&lt;/p&gt;
&lt;p&gt;弹性布局是一种全新的思维方式，让很多实现复杂的问题有了更好的理解方式（如垂直居中）。只需要给&lt;strong&gt;直接&lt;/strong&gt;父容器设置为&lt;code&gt;display: flex;&lt;/code&gt; ，duang~ 子元素就默认具有了&lt;strong&gt;可收缩性&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://alisec-ued.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>使用Webpack打包时的“多页”实践</title>
    <link href="https://alisec-ued.github.io/2016/12/13/%E4%BD%BF%E7%94%A8Webpack%E6%89%93%E5%8C%85%E6%97%B6%E7%9A%84%E2%80%9C%E5%A4%9A%E9%A1%B5%E2%80%9D%E5%AE%9E%E8%B7%B5/"/>
    <id>https://alisec-ued.github.io/2016/12/13/使用Webpack打包时的“多页”实践/</id>
    <published>2016-12-13T02:30:41.000Z</published>
    <updated>2016-12-13T03:58:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack在”多页“开发中遇到的问题"><a href="#Webpack在”多页“开发中遇到的问题" class="headerlink" title="Webpack在”多页“开发中遇到的问题"></a>Webpack在”多页“开发中遇到的问题</h2><p>在开发时我们经常使用Webpack官方提供的<code>webpack-dev-server</code>插件。我们只需要通过一个入口<code>main.js</code>和入口页面HTML，用<code>webpack-dev-server</code>就能够提供热更新“Live Reload”以及热替换“Hot Module Replacement”（即HMR） ，这很方便，但是在实际项目中我们遇到了更复杂的场景。 </p>
<p>举例来说，我们现在的一个项目中不仅仅只是一个SPA应用了，它可能是由多个SPA应用构成的一个项目，每个SPA应用可能会由不同的人维护。因此它会有<strong>多个入口JS和入口HTML</strong>。由于没有提供唯一的入口js和html，仅仅使用<code>webpack-dev-server</code>的方案就行不通了。对于这种”多页应用“的项目，最好的方案是在开发时能通过路由切换到对应的SPA应用下，即对应的入口JS和HTML下，为此我们需要一些小技巧。</p>
<a id="more"></a>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>其实在使用Webpack以前其实我们不会有这种烦恼，也许这就是“螺旋式上升”的必经之路。总之，我一开始能想到的方案有以下三种。</p>
<ol>
<li>在开发模式下通过Gulp监听文件变化，然后直接使用Webpack打包出文件，用Gulp-Server处理路由。</li>
<li>任然使用webpack-dev-server，通过proxy代理另一个Server处理路由。</li>
<li>只起一个Server + WebpackMiddleware 在保留热更新和热替换的基础上，增加多路由。</li>
</ol>
<p>三种方法各有利弊。在此我们选择第三种方式，通过独立Server我们能够更方便的处理Mock中Post请求以及Prox等问题，自由度更大。</p>
<p><img src="https://img.alicdn.com/tps/TB1rSsdOFXXXXbiXpXXXXXXXXXX-1026-598.png" alt="server.png"><br>图片中的<code>multientry-dev-server</code>就是接下来我们要创造的server。</p>
<h2 id="Webpack-Dev-Hot-Middleware"><a href="#Webpack-Dev-Hot-Middleware" class="headerlink" title="Webpack Dev\Hot Middleware"></a>Webpack Dev\Hot Middleware</h2><p>官方提供的<code>webpack-dev-server</code>也只是一个用Express起的Server而已，其中使用了<code>webpack-dev-middleware</code> 和 <code>webpack-hot-middleware</code>作为中间件提供<code>Hot Module Replacement/Hot Reloading</code>能力。Webpack Hot Middleware 必须要搭配Webpack Dev Middleware才能使用，因此同样的我们也可以用Express启动一个有热替换功能的服务器，<code>webpack-dev-server</code>只是做了一个简单的封装而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> webpackMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</div><div class="line"><span class="keyword">var</span> webpackHotMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>);</div></pre></td></tr></table></figure>
<p>通过下面的代码建立Webpack的实例以及使用中间件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = express();</div><div class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig);</div><div class="line"><span class="keyword">var</span> middleware = webpackMiddleware(compiler, &#123;</div><div class="line">  <span class="attr">publicPath</span>: webpackConfig.output.publicPath</div><div class="line">&#125;);</div><div class="line">app.use(middleware);</div><div class="line">app.use(webpackHotMiddleware(compiler));</div></pre></td></tr></table></figure></p>
<h2 id="通过路由获取内存中的Webapck打包文件"><a href="#通过路由获取内存中的Webapck打包文件" class="headerlink" title="通过路由获取内存中的Webapck打包文件"></a>通过路由获取内存中的Webapck打包文件</h2><p>使用webpack中间件打包并不会真正的生成文件，它会把文件载入到内存中。<br>为了能通过路由指定跳转到对应的入口JS和HTML，我们在需在项目中做一些约定。假设项目入口为<code>apps</code>目录，该目录下的每一个子目录对应一个SPA应用，在子目录中需要通过一个<code>package.json</code>指定该SPA应用的入口JS和这个SPA应用的其他信息，比如名字和子应用负责人等。<br><img src="https://img.alicdn.com/tps/TB1svDMOFXXXXXbapXXXXXXXXXX-753-497.png" alt="基础模板1.png"><br>package.json文件格式类似如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"app1"</span>,</div><div class="line">  <span class="attr">"main"</span>: <span class="string">"./main.js"</span>,</div><div class="line">  <span class="attr">"author"</span>: <span class="string">"左伦"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>middleware提供了<code>middleware.fileSystem.readFileSync</code>方法读取内存中的文件，文件的地址就是在webpack中配置的输出地址。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/:appName'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> htmlPath = path.join(__dirname, webpackConfig.output.path + req.params.appName + <span class="string">'/index.html'</span>);</div><div class="line">  <span class="built_in">console</span>.log(htmlPath);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    result = middleware.fileSystem</div><div class="line">      .readFileSync(htmlPath);</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    result = err.toString();</div><div class="line">  &#125;</div><div class="line">  res.write(result);</div><div class="line">  res.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>OK, 至此便可以通过路由指定到对应App的入口。</p>
<h2 id="Mock数据以及“首页”"><a href="#Mock数据以及“首页”" class="headerlink" title="Mock数据以及“首页”"></a>Mock数据以及“首页”</h2><p>由于是独立启动的Server，我们可以很方便的在Server中指定任意目录作为我们的静态目录，同时处理好对应的Post请求。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 静态资源，Mock GET请求</span></div><div class="line">app.use(express.static(path.join(__dirname, <span class="string">'../'</span>)));</div><div class="line"><span class="comment">// Mock POST请求</span></div><div class="line">app.post(<span class="string">'/api/*'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.sendFile(path.join(__dirname, <span class="string">'../api'</span>, req.params[<span class="number">0</span>]));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>当越来越多的子App在项目中后，通过手动在浏览器中输入路由再进行跳转会显得十分麻烦。因此可以在Server中新增一个“首页”，列出当前项目下的所有子应用以及开发时的对应路由，具体实现并不难，通过遍历目录下每个应用中的Packge.json即可，最后效果如下:<br><img src="https://img.alicdn.com/tps/TB1pwkrOFXXXXbuXXXXXXXXXXXX-840-562.jpg" alt="屏幕快照 2016-12-11 下午7.11.20.png"><br>终于不用每次在浏览器中敲地址了..<br>到目前为止，已经成功解决了Webpack在“多页“应用下的开发问题，接下来是时候更进一步了。</p>
<h2 id="使用target指定入口应用"><a href="#使用target指定入口应用" class="headerlink" title="使用target指定入口应用"></a>使用<code>target</code>指定入口应用</h2><p>之前说到Webpack中间件在构建时会把文件都读取到内存中，但是当我们的项目越来越大的时候，项目下会有越来越多的子应用，这就造成了另一问题。有时我们只是在开发某一个子App下的代码，但是Webpack每次都会把整个项目打包进内存，非常浪费资源。因此这里我们可以在webpack的配置文件中做点文章，想办法只打包我们需要的目录下的JS。</p>
<p>在执行<code>npm start</code>的时候，通过在命令行里用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">target=appName1,appName2 npm start</div></pre></td></tr></table></figure></p>
<p>其中appName为你想要启动的应用名称（名称在package.json中定义），此时Webpack配置中的Entry只会包含target指定应用名下的入口JS和HTML，大大缩短了Webpack启动时间并且减少了内存占用。这个想法最初是在团队的另一位师兄的代码中看到的，十分巧妙，关键代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> targetEntries = process.env.target;</div><div class="line">targetEntries = targetEntries ? targetEntries.split(<span class="string">','</span>) : <span class="string">''</span>;</div><div class="line">  targetEntries.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'应用: '</span>, value);</div><div class="line">    entryPath = path.join(viewsDir, value);</div><div class="line">    entryJson = fse.readJsonSync(path.join(entryPath, <span class="string">'/package.json'</span>));</div><div class="line">    entryMap[value] = [path.resolve(path.join(entryPath, entryJson.main))];</div><div class="line">    <span class="keyword">var</span> appName = entryJson.name;</div><div class="line">    <span class="keyword">var</span> tplPath = path.join(entryPath, <span class="string">'/index.html'</span>);</div><div class="line">    <span class="keyword">var</span> conf = &#123;</div><div class="line">      <span class="attr">template</span>: tplPath,</div><div class="line">      <span class="attr">filename</span>: path.join(appName, <span class="string">'index.html'</span>),</div><div class="line">      <span class="attr">inject</span>: <span class="string">'body'</span>,</div><div class="line">      <span class="attr">chunks</span>: [appName]</div><div class="line">    &#125;;</div><div class="line">    htmlPluginsArr.push(<span class="keyword">new</span> HtmlWebpackPlugin(conf));</div><div class="line">  &#125;);</div><div class="line">  _.extend(webpackConfig, &#123;</div><div class="line">    <span class="attr">entry</span>: entryMap,</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">      <span class="attr">path</span>: path.join(__dirname, <span class="string">'../build/'</span>),</div><div class="line">      <span class="attr">filename</span>: <span class="string">'[name]/[name].min.js'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">plugins</span>: [</div><div class="line">      <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name]/[name].css'</span>),</div><div class="line">      <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">        <span class="attr">compress</span>: &#123;</div><div class="line">          <span class="attr">warnings</span>: <span class="literal">false</span>,</div><div class="line">          <span class="attr">drop_console</span>: <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    ].concat(htmlPluginsArr)</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>通过这样一个简单的服务，我们完全不用再使用Webpack-Dev-Server了，甚至我们也可以封装成一个相似的plugin。整个问题的思路和解决方案到此为止咯，如果大家有更好的想法可以补充。</p>
<p>文章首发于<a href="https://alisec-ued.github.io/2016/12/13/%E4%BD%BF%E7%94%A8Webpack%E6%89%93%E5%8C%85%E6%97%B6%E7%9A%84%E2%80%9C%E5%A4%9A%E9%A1%B5%E2%80%9D%E5%AE%9E%E8%B7%B5/">alisec-ued</a> ，个人博客<a href="http://jolyon.cc" target="_blank" rel="external">地址</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Webpack在”多页“开发中遇到的问题&quot;&gt;&lt;a href=&quot;#Webpack在”多页“开发中遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;Webpack在”多页“开发中遇到的问题&quot;&gt;&lt;/a&gt;Webpack在”多页“开发中遇到的问题&lt;/h2&gt;&lt;p&gt;在开发时我们经常使用Webpack官方提供的&lt;code&gt;webpack-dev-server&lt;/code&gt;插件。我们只需要通过一个入口&lt;code&gt;main.js&lt;/code&gt;和入口页面HTML，用&lt;code&gt;webpack-dev-server&lt;/code&gt;就能够提供热更新“Live Reload”以及热替换“Hot Module Replacement”（即HMR） ，这很方便，但是在实际项目中我们遇到了更复杂的场景。 &lt;/p&gt;
&lt;p&gt;举例来说，我们现在的一个项目中不仅仅只是一个SPA应用了，它可能是由多个SPA应用构成的一个项目，每个SPA应用可能会由不同的人维护。因此它会有&lt;strong&gt;多个入口JS和入口HTML&lt;/strong&gt;。由于没有提供唯一的入口js和html，仅仅使用&lt;code&gt;webpack-dev-server&lt;/code&gt;的方案就行不通了。对于这种”多页应用“的项目，最好的方案是在开发时能通过路由切换到对应的SPA应用下，即对应的入口JS和HTML下，为此我们需要一些小技巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Webpack" scheme="https://alisec-ued.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>前后端渲染模板一致性的思考</title>
    <link href="https://alisec-ued.github.io/2016/12/07/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%A8%A1%E6%9D%BF%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://alisec-ued.github.io/2016/12/07/前后端渲染模板一致性的思考/</id>
    <published>2016-12-07T07:29:28.000Z</published>
    <updated>2016-12-07T07:33:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一般情况下，前后端合作模式是这样："><a href="#一般情况下，前后端合作模式是这样：" class="headerlink" title="一般情况下，前后端合作模式是这样："></a>一般情况下，前后端合作模式是这样：</h4><ul>
<li>前端负责把设计稿实现成静态的页面demo，并且把一些资源部署到CDN；</li>
<li>后端同学将静态demo修改成后端模板（如<code>vm</code>、<code>xtpl</code>、<code>jade</code>、<code>ejs</code>等）。<br>这里有一个很明显的耦合问题：<br>前后端使用的模板不一致了，导致后期维护成本巨大。由于在模板中可能嵌入了很多业务逻辑，当其他同学来接手项目时，往往容易在不完全理解业务逻辑的情况改出<code>bug</code>。这个在我接触的项目中有活生生的例子。</li>
</ul>
<p>为了提高项目后期可维护性，应该降低这种耦合性，后端同学应该直接使用模板，而不需要通过修改<code>html</code>文件来创建模板。</p>
<h5 id="当然这样又会有两个问题："><a href="#当然这样又会有两个问题：" class="headerlink" title="当然这样又会有两个问题："></a>当然这样又会有两个问题：</h5><ul>
<li>一是前端工作量增大</li>
<li>二是开发约定更为严格。</li>
</ul>
<a id="more"></a>
<p>这两个问题对于前期来说是比较痛苦的，但是随着这种模式的推进，后面会变得越来越容易实现。</p>
<p>当然你可能会说，前后端分离的项目就不存在这种情况。简单的前后端分离项目，因为<code>view层</code>渲染还是由前端来做，并不会出现这种情况。但对于复杂的前后端分离项目，所有引用资源都是在<code>CDN</code>上的，<code>CDN</code>部署是页面完成时直接部署，此外如果中间层数据量大的话（进而导致工作量大），静态页面也可能不是同一人来写。这样问题又回到了一般的前后端合作模式。</p>
<p>于是，使用前后端模板渲染保持一致就是一种解决方案了，这里利用<code>webpack</code>来搭建这样的开发模式。</p>
<h4 id="目前想到的方案大致分为两种（使用xtpl模板引擎）："><a href="#目前想到的方案大致分为两种（使用xtpl模板引擎）：" class="headerlink" title="目前想到的方案大致分为两种（使用xtpl模板引擎）："></a>目前想到的方案大致分为两种（使用<code>xtpl</code>模板引擎）：</h4><ul>
<li>结合<code>html-webpack-plugin</code>插件的template配置参数，编写符合需求的xtpl模板loader；</li>
<li>从内存中获取入口<code>xtpl</code>文件（已经过<code>html-webpack-plugin</code>处理），再通过其映射关系从硬盘中读取其他模板文件。</li>
</ul>
<p>对于第一种方案，你也许会有疑问，<code>template</code>参数不是支持<code>loader</code>加载吗？先来看看这种情况：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// ./extend.xtpl</div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>extend<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">&#123;&#123;&#123;block ('body')&#125;&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line">// ./index.xtpl</div><div class="line">&#123;&#123;extend ('./extend.xtpl')&#125;&#125;</div><div class="line">&#123;&#123;#block ('body')&#125;&#125;</div><div class="line">title: &#123;&#123;title&#125;&#125;</div><div class="line">&#123;&#123;test&#125;&#125;jlk</div><div class="line">&#123;&#123;include ('./content.xtpl')&#125;&#125;</div><div class="line">&#123;&#123;/block&#125;&#125;</div><div class="line"></div><div class="line">// ./content.xtpl</div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当<code>html-webpack-plugin</code>载入<code>index.xtpl</code>文件时，<code>xtpl-loader</code>并没有解析<code>./content.xtpl</code>这个文件，而是返回一个含有<code>require</code>语法的<code>function</code>模板函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// xtpl-loader模块部分代码</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> webpackRemainingChain = loaderUtils.getRemainingRequest(<span class="keyword">this</span>).split(<span class="string">'!'</span>);</div><div class="line">  <span class="keyword">var</span> filename = webpackRemainingChain[webpackRemainingChain.length - <span class="number">1</span>];</div><div class="line">  <span class="keyword">var</span> result = xtemplateCompiler.compileToStr(&#123;</div><div class="line">    <span class="attr">name</span>: filename,</div><div class="line">    <span class="attr">isModule</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">withSuffix</span>:<span class="string">'xtpl'</span>,</div><div class="line">    <span class="attr">content</span>: source,</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">this</span>.cacheable();</div><div class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, <span class="string">`module.exports = <span class="subst">$&#123;result&#125;</span>`</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// xtpl-loader返回的数据result字串，此时的require语法是webpack里的require函数</span></div><div class="line"><span class="comment">// ...code</span></div><div class="line">buffer = root.includeModule(scope, &#123;  <span class="attr">params</span>: [ <span class="built_in">require</span>(<span class="string">"./content.xtpl"</span>) ] &#125;, buffer,tpl);</div><div class="line"><span class="comment">// ...code</span></div></pre></td></tr></table></figure>
<p>当我们使用<code>express</code>服务器渲染这个模板时，并不能正确解析<code>./contetn.xtpl</code>这个文件。当然，正是这个问题我们才有了方案一。</p>
<h4 id="现在让我们来开始尝试"><a href="#现在让我们来开始尝试" class="headerlink" title="现在让我们来开始尝试"></a>现在让我们来开始尝试</h4><p>1、结合html-webpack-plugin插件的template配置参数，编写符合需求的xtpl模板loader<br>这里又分为2中方式：</p>
<ul>
<li>写loader，解析include、extend等模板拼接语法<br>这个工作量和困难度都很大，并且对于不同模板还需要不同实现，所以直接舍弃。</li>
<li>在loader里将所有数据与模板渲染完成，由loader直接返回一个渲染好的字符串，再由express服务器把字符串直接输出到浏览器。</li>
</ul>
<p><code>xtpl-compiler-loader</code>自己编写的<code>laoder</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xtpl = <span class="built_in">require</span>(<span class="string">'xtpl'</span>);</div><div class="line"><span class="keyword">var</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.cacheable();</div><div class="line">  <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</div><div class="line">  <span class="keyword">var</span> webpackRemainingChain = loaderUtils.getRemainingRequest(<span class="keyword">this</span>).split(<span class="string">'!'</span>);</div><div class="line">  <span class="keyword">var</span> temp = webpackRemainingChain[webpackRemainingChain.length - <span class="number">1</span>].split(<span class="string">'?'</span>);</div><div class="line">  <span class="keyword">var</span> filename = temp[<span class="number">0</span>];</div><div class="line">  <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(temp[<span class="number">1</span>].split(<span class="string">'='</span>)[<span class="number">1</span>]);</div><div class="line">  xtpl.renderFile(filename, &#123;<span class="attr">title</span>: <span class="string">'fdsa'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e, content</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(e,content);</div><div class="line">    callback(<span class="literal">null</span>, content);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>html-webpack-plugin</code>配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> htmlWebpackPlugin(&#123;</div><div class="line">  <span class="comment">// ...option</span></div><div class="line">  template: <span class="string">'xtpl-compiler-loader!'</span> + filePath + <span class="string">'?data=&#123;"title": "title"&#125;'</span>,</div><div class="line">  <span class="comment">// ...option</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>express</code>服务器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack编译器</span></div><div class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig);</div><div class="line"></div><div class="line"><span class="comment">// webpack-dev-server中间件</span></div><div class="line"><span class="keyword">var</span> devMiddleware = WebpackDevMiddleware(compiler, &#123;</div><div class="line">  <span class="attr">publicPath</span>: webpackConfig.output.publicPath,</div><div class="line">  <span class="attr">stats</span>: &#123;</div><div class="line">    <span class="attr">colors</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">chunks</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line">app.use(devMiddleware);</div><div class="line">app.use(webpackHotMiddleware(compiler));</div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> filePath = compiler.outputPath; <span class="comment">// loader输出的内存文件目录</span></div><div class="line">  <span class="keyword">var</span> fileContent = devMiddleware.fileSystem.readFileSync(filePath).toString();</div><div class="line">  res.set(<span class="string">'content-type'</span>, <span class="string">'text/html'</span>);</div><div class="line">  res.send(fileContent);</div><div class="line">  res.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>经过上面的配置后，webpack能正确解析模板的i<code>nclude</code>、<code>extend</code>等语法，但是有2个槽点：<br>第一：无法实时监听当子模板的修改；<br>第二：在<code>template</code>参数传入data数据很奇怪，容易让人困惑。<br>因为槽点一，放弃了这个方案。</p>
<p>2、从内存中获取入口<code>xtpl文件</code>（已经过<code>html-webpack-plugin</code>注入处理），再通过其映射关系从硬盘中读取其他模板文件。<br>这种方式在逻辑上完全没有问题（而且不用自己写loader），因为只有一个文件是存储在内存中，而其他文件都是通过映射关系实时从硬盘中读取。</p>
<p><code>html-webpack-plugin</code>配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 字符串方式读取文件</span></div><div class="line"><span class="keyword">new</span> htmlWebpackPlugin(&#123;</div><div class="line">  <span class="comment">// ...option</span></div><div class="line">  template: filePath + <span class="string">'?variable=data'</span>,</div><div class="line">  <span class="comment">// ...option</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>express</code>服务器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack编译器</span></div><div class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig);</div><div class="line"></div><div class="line"><span class="comment">// webpack-dev-server中间件</span></div><div class="line"><span class="keyword">var</span> devMiddleware = WebpackDevMiddleware(compiler, &#123;</div><div class="line">  <span class="attr">publicPath</span>: webpackConfig.output.publicPath,</div><div class="line">  <span class="attr">stats</span>: &#123;</div><div class="line">    <span class="attr">colors</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">chunks</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> filePath = compiler.outputPath;</div><div class="line">  <span class="keyword">var</span> fileContent = devMiddleware.fileSystem.readFileSync(filePath).toString();</div><div class="line"></div><div class="line">  <span class="comment">// truePath是指filePath内存文件路径匹配的硬盘路径</span></div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> xtemplate(fileContent, &#123;</div><div class="line">    <span class="attr">name</span>: truePath,</div><div class="line">    <span class="attr">loader</span>: xtpl.loader,</div><div class="line">    <span class="attr">extname</span>: <span class="string">'xtpl'</span>,</div><div class="line">    <span class="attr">encoding</span>: <span class="string">'utf-8'</span></div><div class="line">  &#125;).render(fse.readJsonSync(config.jsonUrl));</div><div class="line">  res.set(<span class="string">'content-type'</span>, <span class="string">'text/html'</span>);</div><div class="line">  res.send(result);</div><div class="line">  res.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>存在问题：<br>因为直接拿内存中的字符串进行模板渲染，如果模板中含有include、extend等语法，这些包含与继承的相对路径并没有一个路径基准，所以必须手动指定一个路径基准，在<code>vm</code>模板引擎中与有参数可以设置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Engine = <span class="built_in">require</span>(<span class="string">'velocity'</span>).Engine;</div><div class="line"><span class="keyword">new</span> Engine(&#123;<span class="attr">template</span>: content, <span class="attr">root</span>: rootPath);</div></pre></td></tr></table></figure></p>
<p>但在使用<code>xtpl</code>模板存在的问题：<br>第一：<code>xtpl</code>提供的配置参数中并没有类似<code>root</code>参数；<br>第二：<code>xtpl.loader</code>函数并没有被模块<code>xtpl</code>暴露出来，<a href="https://github.com/xtemplate/xtpl/blob/master/lib/xtpl.js" target="_blank" rel="external">点这里看源码</a>。</p>
<p>最后阅读了<code>xtpl</code>源码，从代码调用栈中发现，子模板路径都是相对于父模板路径，而且指定<code>name</code>参数就是父模板的路径。这里解决了第一个问题。<br>第二个问题是由于<code>XTemplate</code>里没有显式的给出<code>loader</code>，<code>loader</code>是模板的加载器，见<a href="https://github.com/xtemplate/xtpl/blob/master/lib/xtpl.js#L130" target="_blank" rel="external">这里</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> loader = &#123;</div><div class="line">    <span class="attr">load</span>: <span class="function"><span class="keyword">function</span> (<span class="params">tpl, callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> template = tpl.root;</div><div class="line">        <span class="keyword">var</span> path = tpl.name;</div><div class="line">        <span class="keyword">var</span> rootConfig = template.config;</div><div class="line">        <span class="keyword">var</span> extname = rootConfig.extname;</div><div class="line">        <span class="keyword">var</span> pathExtName;</div><div class="line">        <span class="keyword">if</span> (endsWith(path, extname)) &#123;</div><div class="line">            pathExtName = extname;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            pathExtName = Path.extname(path);</div><div class="line">            <span class="keyword">if</span> (!pathExtName) &#123;</div><div class="line">                pathExtName = extname;</div><div class="line">                path += pathExtName;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (pathExtName !== extname) &#123;</div><div class="line">            readFile(path, rootConfig, callback);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            getTplFn(template, path, rootConfig, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>因为模块中没有暴露出<code>loader</code>接口，所以要解决第二个问题只能自己写一个<code>npm</code>包来实现<code>loader</code>的功能。</p>
<p>当前的开发模式采用的是第二种模式，因为实现起来更容易，逻辑也更清晰，功能也完善。</p>
<p>欢迎补充！~~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一般情况下，前后端合作模式是这样：&quot;&gt;&lt;a href=&quot;#一般情况下，前后端合作模式是这样：&quot; class=&quot;headerlink&quot; title=&quot;一般情况下，前后端合作模式是这样：&quot;&gt;&lt;/a&gt;一般情况下，前后端合作模式是这样：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;前端负责把设计稿实现成静态的页面demo，并且把一些资源部署到CDN；&lt;/li&gt;
&lt;li&gt;后端同学将静态demo修改成后端模板（如&lt;code&gt;vm&lt;/code&gt;、&lt;code&gt;xtpl&lt;/code&gt;、&lt;code&gt;jade&lt;/code&gt;、&lt;code&gt;ejs&lt;/code&gt;等）。&lt;br&gt;这里有一个很明显的耦合问题：&lt;br&gt;前后端使用的模板不一致了，导致后期维护成本巨大。由于在模板中可能嵌入了很多业务逻辑，当其他同学来接手项目时，往往容易在不完全理解业务逻辑的情况改出&lt;code&gt;bug&lt;/code&gt;。这个在我接触的项目中有活生生的例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了提高项目后期可维护性，应该降低这种耦合性，后端同学应该直接使用模板，而不需要通过修改&lt;code&gt;html&lt;/code&gt;文件来创建模板。&lt;/p&gt;
&lt;h5 id=&quot;当然这样又会有两个问题：&quot;&gt;&lt;a href=&quot;#当然这样又会有两个问题：&quot; class=&quot;headerlink&quot; title=&quot;当然这样又会有两个问题：&quot;&gt;&lt;/a&gt;当然这样又会有两个问题：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;一是前端工作量增大&lt;/li&gt;
&lt;li&gt;二是开发约定更为严格。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://alisec-ued.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>flex&amp;&amp;table-cell解决列表布局</title>
    <link href="https://alisec-ued.github.io/2016/12/02/flex%E5%B8%83%E5%B1%80/"/>
    <id>https://alisec-ued.github.io/2016/12/02/flex布局/</id>
    <published>2016-12-02T03:37:31.000Z</published>
    <updated>2016-12-02T08:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文要解决的问题：列表的布局。</p>
<p>一直以来，栅格布局由于其响应式的特点广为应用，但它的原理是将一列分为12份再进行组合，所以对于每列宽度的划分不是很灵活。</p>
<p>本文介绍flex、table-cell两种方式，来解决列表问题。</p>
<ul>
<li>使列表宽度灵活定义，并能根据屏幕大小进行自适应。</li>
<li>解决不定高度的行，内容垂直居中、水平居中的问题。</li>
<li>解决响应式的问题（采用媒体查询）。</li>
</ul>
<a id="more"></a>
<h4 id="基本知识的介绍："><a href="#基本知识的介绍：" class="headerlink" title="基本知识的介绍："></a>基本知识的介绍：</h4><h6 id="flex："><a href="#flex：" class="headerlink" title="flex："></a>flex：</h6><p> 是一种不同于盒模型的布局方式，它是一种弹性布局可以便捷的实现各种布局。</p>
<ul>
<li>添加display属性的取值flex。</li>
<li>该布局中引入主轴、交叉轴的概念。</li>
<li>主轴可以指横向、也可以指纵向，由<code>flex-direction</code>属性的取值决定。</li>
<li>主轴确定后，与其交叉的方向即为纵轴。</li>
<li>在该布局下存在类似float、vertical-align功能的新属性，所以float、clear、vertical-align不再生效。</li>
<li>本例中用到的属性：<ul>
<li><code>flex-basis</code>：用于子元素上设置宽度，与width类似。</li>
<li><code>justify-content</code>: 用于父元素上，设置主轴上的对齐方式，可取<code>flex-start</code> | <code>flex-end</code> |<code>center</code> |<code>space-between</code> |<code>space-around</code>;</li>
<li><code>align-items</code>: 用于父元素上，设置交叉轴上的对齐方式，可取<code>flex-start</code> | <code>flex-end</code> |<code>center</code> |<code>space-between</code> |<code>space-around</code>;</li>
</ul>
</li>
<li>flex介绍可参考<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">flex教程</a></li>
</ul>
<h6 id="table-cell："><a href="#table-cell：" class="headerlink" title="table-cell："></a>table-cell：</h6><p>table布局是一种传统的布局方式，<code>display:table-cell</code>去掉了table标签，用css的形式实现类似的布局，去掉了语义化。</p>
<ul>
<li>当display设置为table-cell时元素类似一个单元格，对margin不敏感，只对padding敏感。</li>
<li>对高度敏感，当同行其他列高度变化时，该列高度随之变化，vertical-align也可以使内部元素动态垂直居中。</li>
<li><code>table-cell</code>是一个较早的属性，其兼容性较好。</li>
<li>可以在内部嵌套栅格布局，不会引起冲突。</li>
</ul>
<h4 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h4><ul>
<li>希望固定操作列的宽度。</li>
<li>其他列的宽度可以根据屏幕的宽度自适应。</li>
<li>当屏幕宽度过窄时，折行显示。</li>
</ul>
<h4 id="flex实现："><a href="#flex实现：" class="headerlink" title="flex实现："></a>flex实现：</h4><p>DOM结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item0"</span>&gt;</span></div><div class="line">    这里是列表内容</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span></div><div class="line">  	操作</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS样式：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">//采用背景颜色来标注div位置</span></div><div class="line">  <span class="attribute">display</span>: flex;  <span class="comment">// 外层div采用flex布局</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item0</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: grey;</div><div class="line">  <span class="attribute">flex-basis</span>: <span class="number">100%</span>; <span class="comment">// 宽度占满除操作列之外的宽度 </span></div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;  <span class="comment">// 设置内容列高度，也可让其随内容变化</span></div><div class="line">  <span class="comment">/**以下解决内容水平、垂直居中问题**/</span></div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">// 操作列内容水平居中</span></div><div class="line">  <span class="attribute">align-items</span>: center; <span class="comment">// 操作列内容垂直居中</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item1</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: purple;</div><div class="line">  <span class="attribute">flex-basis</span>: <span class="number">80px</span>;  <span class="comment">// 固定操作列宽度</span></div><div class="line">  <span class="attribute">min-height</span>: <span class="number">40px</span>;  <span class="comment">// 设置操作列最小高度，真是高度随内容列高度变化</span></div><div class="line">  <span class="comment">/**以下解决内容水平、垂直居中问题**/</span></div><div class="line">  <span class="attribute">display</span>: flex;  <span class="comment">// 设置操作列布局方式</span></div><div class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">// 操作列内容水平居中</span></div><div class="line">  <span class="attribute">align-items</span>: center; <span class="comment">// 操作列内容垂直居中</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**响应式处理**/</span></div><div class="line">@<span class="keyword">media</span> screen and (max-width: 750px)&#123;</div><div class="line">  <span class="selector-class">.container</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;  <span class="comment">// 当屏幕宽度小于750px时，将外层布局变为block；此时两列各占一行。内部内容仍然是flex布局。</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>元素内部需要<code>flex</code>布局，需要设置该元素<code>display:flex</code>。</li>
</ul>
<h4 id="table-cell实现"><a href="#table-cell实现" class="headerlink" title="table-cell实现:"></a>table-cell实现:</h4><p>DOM结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-inner"</span>&gt;</span></div><div class="line">        这里是列表内容</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-inner"</span>&gt;</span></div><div class="line">        操作</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**实现外层布局**/</span></div><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: pink;</div><div class="line">  <span class="attribute">display</span>: table;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item0</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: grey;</div><div class="line">  <span class="attribute">display</span>: table-cell;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item1</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: purple;</div><div class="line">  <span class="attribute">display</span>: table-cell;</div><div class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</div><div class="line">  <span class="attribute">min-height</span>: <span class="number">40px</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**实现内容居中**/</span></div><div class="line"><span class="selector-class">.content</span> &#123;</div><div class="line">  <span class="attribute">display</span>: table;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.content-inner</span> &#123;</div><div class="line">  <span class="attribute">display</span>: table-cell;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**实现响应式**/</span></div><div class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">750px</span>)&#123;</div><div class="line">  <span class="selector-class">.container</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.item0</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.item1</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>父元素需要设置<code>display:table</code> 。</li>
<li>子元素<code>display:table-cell</code>,且设置了高度或者其他列设置了高度，<code>vertical-align: middle;</code>才能生效。</li>
</ul>
<h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><h5 id="屏幕宽度-gt-750px"><a href="#屏幕宽度-gt-750px" class="headerlink" title="屏幕宽度&gt;750px"></a>屏幕宽度&gt;750px</h5><p><img src="https://img.alicdn.com/tps/TB1JZwKOpXXXXaGaXXXXXXXXXXX-2158-230.png" alt="图片"></p>
<h5 id="屏幕宽度-lt-750px"><a href="#屏幕宽度-lt-750px" class="headerlink" title="屏幕宽度&lt;750px"></a>屏幕宽度&lt;750px</h5><p><img src="https://img.alicdn.com/tps/TB1DaIVOpXXXXa5XVXXXXXXXXXX-1406-312.png" alt="响应后"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>flex用简单的样式，就实现了不定高垂直居中，宽度灵活自适应，flex目前所有类型浏览器都已支持，只是某些低版本浏览器会存在兼容性问题。table-cell兼容性良好，但稍显复杂。总体来看flex才是大势所趋。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文要解决的问题：列表的布局。&lt;/p&gt;
&lt;p&gt;一直以来，栅格布局由于其响应式的特点广为应用，但它的原理是将一列分为12份再进行组合，所以对于每列宽度的划分不是很灵活。&lt;/p&gt;
&lt;p&gt;本文介绍flex、table-cell两种方式，来解决列表问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使列表宽度灵活定义，并能根据屏幕大小进行自适应。&lt;/li&gt;
&lt;li&gt;解决不定高度的行，内容垂直居中、水平居中的问题。&lt;/li&gt;
&lt;li&gt;解决响应式的问题（采用媒体查询）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://alisec-ued.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>图解Redux数据流(二)</title>
    <link href="https://alisec-ued.github.io/2016/11/28/%E5%9B%BE%E8%A7%A3Redux%E6%95%B0%E6%8D%AE%E6%B5%81(%E4%BA%8C)/"/>
    <id>https://alisec-ued.github.io/2016/11/28/图解Redux数据流(二)/</id>
    <published>2016-11-27T17:17:40.000Z</published>
    <updated>2016-11-28T03:10:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章回答了前两个问题，而这一篇则回答最后一个问题。</p>
<h2 id="Redux如何使用？"><a href="#Redux如何使用？" class="headerlink" title="Redux如何使用？"></a>Redux如何使用？</h2><p>前一篇文章描述了Redux的基本要素，并且梳理了一下Redux的数据流动图</p>
<p><img src="https://img.alicdn.com/tps/TB1vRLKOpXXXXacaXXXXXXXXXXX-889-271.png" alt="Alt text"></p>
<p>首先，我们的View上体现出的任何操作或者事件都会调用Dispatch方法触发Action<br>Action 会告知了type和data<br>然后，Store自动调用Reducer，并且传入两个参数：当前 State和收到的Action。 Reducer会返回新的State 。并且这个过程是纯函数式的，返回的结果由入参决定，不会随着外界的变化而改变。</p>
<p>知道概念了，那么我们从代码层面如何搭建出Redux数据流的架构呢？</p>
<a id="more"></a>
<h3 id="最基本的Redux数据流"><a href="#最基本的Redux数据流" class="headerlink" title="最基本的Redux数据流"></a>最基本的Redux数据流</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = &#123;</div><div class="line">  	<span class="attr">items</span>: []</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action = &#123;&#125;</span>) =&gt;</span> &#123;  </div><div class="line"><span class="keyword">const</span> &#123; type &#125; = action;</div><div class="line"><span class="keyword">switch</span> (type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"ADD_ITEM"</span>:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">        <span class="attr">items</span>: state.items.concat(action.item)</div><div class="line">      &#125;);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"GET_ITEM_LIST"</span>:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">        <span class="attr">items</span>: action.items</div><div class="line">      &#125;);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = createStore(reducer)</div><div class="line"></div><div class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(store.getState())</div><div class="line">&#125;)</div><div class="line"></div><div class="line">store.dispatch(&#123;<span class="attr">type</span>: <span class="string">'GET_ITEM_LIST'</span>,<span class="string">'items'</span>:[&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'test'</span>&#125;]&#125;)</div><div class="line">store.dispatch(&#123;<span class="attr">type</span>: <span class="string">'ADD_ITEM'</span>,<span class="string">'item'</span>:[&#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'test2'</span>&#125;]&#125;)</div><div class="line"></div></pre></td></tr></table></figure>
<p>这个代码段是最简单的Redux数据流例子，把创建Store、ActionCreator、Reducer全放在了一个文件中，在实际项目中，这当然不可取。<br>其实每个Redux的实体概念都可以拆解成一个单独的文件去管理。<br>在项目中为了项目的规范化，我们可以对所有的action_type常量进行统一的管理，放到单独的文件中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> GET_ITEM_LIST = <span class="string">'GET_ITEM_LIST'</span></div><div class="line"><span class="keyword">const</span> ADD_ITEM = <span class="string">'ADD_ITEM'</span></div><div class="line"></div></pre></td></tr></table></figure>
<p>当然，也许最需要进行拆分是Reducer，在有些规模的实际项目中，state往往比较庞大。对于Reducer而言，我们最好根据相应的业务需求拆分出不同Reducer来管理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; createStore,combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">const</span> itemReducer = <span class="function">(<span class="params">state = &#123;&#125;, action = &#123;&#125;</span>) =&gt;</span> &#123;  </div><div class="line">	<span class="keyword">const</span> &#123; type &#125; = action;</div><div class="line">	<span class="keyword">switch</span> (type) &#123;</div><div class="line">	    <span class="keyword">case</span> <span class="string">"ADD_ITEM"</span>:</div><div class="line">	      <span class="keyword">return</span> &#123;</div><div class="line">		      ...state,</div><div class="line">		      <span class="attr">items</span>: state.items.concat(action.item)</div><div class="line">		  &#125;</div><div class="line">	      <span class="keyword">break</span>;</div><div class="line">	    <span class="keyword">case</span> <span class="string">"DELETE_ITEM"</span>:</div><div class="line">	      <span class="keyword">return</span> &#123;</div><div class="line">		      ...state,</div><div class="line">		      <span class="attr">items</span>: state.items.filter(<span class="function">(<span class="params">item</span>)=&gt;</span> &#123;</div><div class="line">		        <span class="keyword">return</span> !(item.id === action.itemId);</div><div class="line">		      &#125;)</div><div class="line">		  &#125;</div><div class="line">		  <span class="keyword">break</span>;</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ListReducer = <span class="function">(<span class="params">state = &#123;items: []&#125;, action</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> &#123; type &#125; = action;</div><div class="line">	<span class="keyword">switch</span> (type) &#123;</div><div class="line">	    <span class="keyword">case</span> <span class="string">"GET_ITEM_LIST"</span>:</div><div class="line">		  <span class="keyword">return</span> &#123;</div><div class="line">		      ...state,</div><div class="line">		      <span class="attr">items</span>: action.items</div><div class="line">		  &#125;</div><div class="line">		  <span class="keyword">break</span>;</div><div class="line">	    <span class="keyword">case</span> <span class="string">"CLEAR_ITEM_LIST"</span>:</div><div class="line">	      <span class="keyword">return</span> &#123;</div><div class="line">		      ...state,</div><div class="line">		      <span class="attr">items</span>: []</div><div class="line">		  &#125;</div><div class="line">		  <span class="keyword">break</span>;</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;itemReducer,ListReducer&#125;)</div><div class="line"></div></pre></td></tr></table></figure>
<p>可以看到，Redux其实本身也提供了combineReducers方法来帮助开发者合并Reducer，可以让每个Reducer互相独立。</p>
<h3 id="Middleware中间件"><a href="#Middleware中间件" class="headerlink" title="Middleware中间件"></a>Middleware中间件</h3><p>Redux中，一切数据都是从一个状态到另一个状态，那么也许我们需要在这个状态间添加一些自己的方法或者功能呢？<br>这个时候就需要Middleware，Middleware发生在发送Action时，也就是调用store.dispatch()。<br>在Middleware中，我们通过调用next(action)函数就可以把Action传递给Reducer。<br>例如一个典型的简易版redux-logger模块，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = &#123;</div><div class="line">  	<span class="attr">items</span>: []</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action = &#123;&#125;</span>) =&gt;</span> &#123;  </div><div class="line"><span class="keyword">const</span> &#123; type &#125; = action;</div><div class="line"><span class="keyword">switch</span> (type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"ADD_ITEM"</span>:</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">	     ...state,</div><div class="line">	      <span class="attr">items</span>: state.items.concat(action.item)</div><div class="line">	  &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"GET_ITEM_LIST"</span>:</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">	     ...state,</div><div class="line">	      <span class="attr">items</span>: action.items</div><div class="line">	  &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> reduxlog = <span class="function"><span class="params">store</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`prev state`</span>, store.getState())</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`action:`</span>, action.type)</div><div class="line">  next(action)</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`next state`</span>,store.getState())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = createStore(reducer, initialState, applyMiddleware(reduxlog))</div><div class="line"></div><div class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(store.getState())</div><div class="line">&#125;)</div><div class="line"></div><div class="line">store.dispatch(&#123;<span class="attr">type</span>: <span class="string">'GET_ITEM_LIST'</span>,<span class="string">'items'</span>:[&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'test'</span>&#125;]&#125;)</div><div class="line">store.dispatch(&#123;<span class="attr">type</span>: <span class="string">'ADD_ITEM'</span>,<span class="string">'item'</span>:[&#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'test2'</span>&#125;]&#125;)</div><div class="line"></div></pre></td></tr></table></figure>
<p><img src="https://img.alicdn.com/tps/TB1j2nuOpXXXXXTapXXXXXXXXXX-840-260.png" alt="Alt text"></p>
<p>中间件处理了改变前和改变后的状态，写法也非常容易理解，如果有业务需要对状态集中处理，通过中间件的方式也不失为一种选择。<br>文章头部的那张图，如果加上中间件，就是这样：</p>
<p><img src="https://img.alicdn.com/tps/TB1BEr9OpXXXXbnXXXXXXXXXXXX-889-287.png" alt="Alt text"></p>
<h3 id="中间件的顺序"><a href="#中间件的顺序" class="headerlink" title="中间件的顺序"></a>中间件的顺序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> store = createStore(</div><div class="line">  reducer,</div><div class="line">  applyMiddleware(thunk, promise, logger)</div><div class="line">);</div><div class="line"></div></pre></td></tr></table></figure>
<p>中间件的调用顺序其实还是有一定讲究，这就要从Middleware本身的设计思想来说明。<br>Redux深受函数式编程的影响，中间件的设计也不例外，</p>
<blockquote>
<p>middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的柯里化 curry，一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地对 store 和 next 参数赋值。</p>
</blockquote>
<p>Redux的applyMiddleware会将所有的中间件组合串联，</p>
<blockquote>
<p>compose 将 chain 中的所有匿名函数，[f1, f2, … , fx, …, fn]，组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, … , fx, …, fn]，从左到右依次执行（ 所以顺序很重要）</p>
</blockquote>
<p>具体中间件的实现思路不详细展开，知乎上有一篇专栏分析的很到位，有兴趣可以看一下 <a href="https://zhuanlan.zhihu.com/p/20597452#!" target="_blank" rel="external">链接</a></p>
<p>上面的例子里如果logger中间件不放置在最后面，输出结果会不正确。</p>
<h3 id="异步问题"><a href="#异步问题" class="headerlink" title="异步问题"></a>异步问题</h3><p>刚刚我们看了那么多示例代码？但是至此，Redux一直没有解决异步的问题。试想，如果我在页面输入一段内容，然后触发了一个动作，此时需要向服务端请求数据并将返回的数据展示出来。这是一个很常见的需求，但是涉及到异步请求，刚刚的示例中的方法已经不再适用了。那么Redux是如何解决异步问题的呢？</p>
<p>没错，还是<strong>Middleware</strong>，Middleware只关注dispatch函数的传递，至于在传递的过程中干了什么中间件并不关心。<br>这里不得不提<strong>redux-thunk</strong>这个中间件</p>
<p>redux-thunk的基本思想就是通过函数来封装异步请求，也就是说在actionCreater中返回一个函数，在这个函数中进行异步调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> next(action);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</div><div class="line">thunk.withExtraArgument = createThunkMiddleware;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</div><div class="line"></div></pre></td></tr></table></figure>    
<p>其实打开redux-thunk的源码看一下，讲真代码量就十几行，那么这里做了什么处理呢？<br>其实关键的就一句代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument);</div><div class="line"> &#125;</div><div class="line"></div></pre></td></tr></table></figure>         
<p>我们知道Action正常其实返回的是一个js对象，如果没有经过Middleware的处理，是不符合Redux逻辑，会抛出异常的，<strong>所以redux-thunk只做了一件事件</strong>，<strong>那就是让Action能够兼容 return 函数</strong>，redux-thunk内部再去消化掉这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">actionCreate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch, getState</span>) </span>&#123;</div><div class="line">        api.fetch(data).then(<span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</div><div class="line">            dispatch(json);</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>    
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是最近一段时间通过在业务不断实践，然后学习和思考的总结。</p>
<p>在这期间发现，很多东西需要事先去积累，要拓宽自己的视野，如果自己不知道某种设计思路并且没有相关经验时，很难想到点上。</p>
<p>技术与业务是相辅相成的，技术能够很好的帮助自己拓宽视野，能设计更好的项目架构；而业务能够让技术得以实践，并且发现技术上可能还存在的问题，从而积累经验。</p>
<p>这个思路我通过这段时间的学习感悟到的，今后的学习也会沿着这个思路走下去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章回答了前两个问题，而这一篇则回答最后一个问题。&lt;/p&gt;
&lt;h2 id=&quot;Redux如何使用？&quot;&gt;&lt;a href=&quot;#Redux如何使用？&quot; class=&quot;headerlink&quot; title=&quot;Redux如何使用？&quot;&gt;&lt;/a&gt;Redux如何使用？&lt;/h2&gt;&lt;p&gt;前一篇文章描述了Redux的基本要素，并且梳理了一下Redux的数据流动图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1vRLKOpXXXXacaXXXXXXXXXXX-889-271.png&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先，我们的View上体现出的任何操作或者事件都会调用Dispatch方法触发Action&lt;br&gt;Action 会告知了type和data&lt;br&gt;然后，Store自动调用Reducer，并且传入两个参数：当前 State和收到的Action。 Reducer会返回新的State 。并且这个过程是纯函数式的，返回的结果由入参决定，不会随着外界的变化而改变。&lt;/p&gt;
&lt;p&gt;知道概念了，那么我们从代码层面如何搭建出Redux数据流的架构呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="https://alisec-ued.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>图解Redux数据流(一)</title>
    <link href="https://alisec-ued.github.io/2016/11/23/%E5%9B%BE%E8%A7%A3Redux%E6%95%B0%E6%8D%AE%E6%B5%81(%E4%B8%80)/"/>
    <id>https://alisec-ued.github.io/2016/11/23/图解Redux数据流(一)/</id>
    <published>2016-11-23T06:37:31.000Z</published>
    <updated>2016-11-28T03:09:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章我只介绍3个问题</p>
<ol>
<li>什么是Redux？</li>
<li>为什么是Redux？</li>
<li>Redux如何使用？</li>
</ol>
<p>##什么是Redux?<br>你们可以看看官网的解释，<br>但是呢，</p>
<p><img src="https://img.alicdn.com/tps/TB1JuYfNVXXXXbmaXXXXXXXXXXX-801-259.jpg" alt="Alt text"></p>
<p>我想没有接触过的人一看肯定一脸懵逼。<br>那么什么是Redux呢？<br>一句话概括，<strong>redux只是一个实现了Flux思想的数据流框架。</strong><br>既然是一个数据流框架，那么数据是如何流动的？</p>
<p><img src="https://img.alicdn.com/tps/TB1kYfaNVXXXXcLaXXXXXXXXXXX-604-352.png" alt="Alt text"></p>
<a id="more"></a>
<p><strong>所谓 Redux，就是将动作(action) 变换成 state 转换函数(reducer)，然后放到一个统一的地方(store)来 setState 而已。</strong></p>
<p>我个人理解的Redux，其特性有3个：</p>
<ol>
<li><strong>单向性</strong><ul>
<li>单向数据流其实并不是redux的特性，而是react本身的思想。这个下面有例子会说明。</li>
</ul>
</li>
<li><strong>唯一性</strong><ul>
<li>指的是应用的数据都会集中存储在一个地方，这个数据Store就像一个<strong>池子</strong>，任何组件都可以通过固定的管道来传输或者获取这个<strong>池子</strong>里面的数据</li>
</ul>
</li>
<li><strong>时间旅行</strong><ul>
<li>这个“时间旅行”另外的意思是可预测（predictable），即容易理解的代码。在redux里，<strong>任何一个数据都有状态</strong>。一个用户操作或者程序需要去修改数据，都必须触发Action，这时在redux看来，其实数据是从一个状态，变化成另一个状态。这么一来，数据就变得可预测，可以知道数据的<strong>前置状态(prev state)</strong>和<strong>后置状态(next state)</strong>分别是什么，如果在这里加上单元测试，也是极其容易的一件事情。</li>
</ul>
</li>
</ol>
<p><img src="https://img.alicdn.com/tps/TB1_62kNVXXXXauaXXXXXXXXXXX-2460-166.png" alt="Alt text"></p>
<p>##为什么是redux<br>曾经有一篇文章叫做<a href="http://www.zcfy.cc/article/you-might-not-need-redux-1334.html" target="_blank" rel="external">《you-might-not-need-redux》</a><br>这篇文章的开头直接揭露了开发者使用redux最为头疼的事情。</p>
<blockquote>
<p>为什么因为一个简单的功能，我需要创建三个文件？到底是为什么？</p>
</blockquote>
<p>那么我们为什么要使用redux呢？<br>Redux的确限定了开发者如何去编写程序。</p>
<blockquote>
<p>Redux提供了一个权衡方案。它规定：</p>
<pre><code>- 用简单的对象和数组来描述应用状态
- 用简单的对象来描述应用中的状态变化
- 用纯函数来描述应用中逻辑变化
</code></pre></blockquote>
<p>这意味着你必须遵循一定的规则才可以让你的程序走通。对应的三个文件分别是<strong>Action</strong>，<strong>Reducer</strong>，<strong>Store</strong>，同时也是Redux最重要的3个概念。</p>
<p>###Action<br>官方的介绍：</p>
<blockquote>
<p>Actions are payloads of information that send data from your application to your store. They are the only source of information for the store. You send them to the store using store.dispatch().</p>
</blockquote>
<p>翻译成中文：</p>
<blockquote>
<p>Actions 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。用法是通过 store.dispatch() 把 action 传到 store。</p>
</blockquote>
<p>还是一脸懵逼？对了，忘了跟你们说了，其实你可以<strong>完全无视</strong>上面的解释。<br>下面我们来玩一个角色扮演的游戏，而我，是导演。哈哈。<br>我们一起来模拟一个战场上情报通讯的场景。</p>
<blockquote>
<p>我：咳咳， Action！你过来，你来当<strong>电报员</strong>。如果战场上有消息，立马给我翻译成<strong>电码</strong>发给我，你知道了吗？<br>Action：yes,sir<br><img src="https://img.alicdn.com/tps/TB1gM_CNVXXXXbLXpXXXXXXXXXX-115-123.png" alt="Alt text"></p>
</blockquote>
<p>###Dispatch<br>Dispatch其实是Redux中三大主角之一Store的亲儿子，但是作为皇子，老子都上了，儿子能不上吗？</p>
<blockquote>
<p>导演：Dispatch！你作为Store的亲儿子，虽然其它能力不行，但至少接电报应该会把。<br>Dispatch：哎，会一点啦会一点<br>我：好，那你给我当<strong>接线员</strong>，给我把Action发给我们的电报转发给Reducer<br> <img src="https://img.alicdn.com/tps/TB14iTtNVXXXXb7XFXXXXXXXXXX-203-176.png" alt="Alt text"></p>
</blockquote>
<p>###Reducer</p>
<blockquote>
<p>我：Reducer！你作为司令（Store）的亲信，帮他处理电报吧。<br>Reducer：这是我的荣幸。<br>我：那好，我认命你为司令部<strong>秘书长</strong>，根据Dispatch转送的电报报头来规整消息，包括筛选和过滤。<br>Reducer：no problem<br><img src="https://img.alicdn.com/tps/TB1Og2INVXXXXavXpXXXXXXXXXX-87-157.png" alt="Alt text"></p>
</blockquote>
<p>###Store</p>
<blockquote>
<p>我：尊敬的<strong>司令</strong>先生，我已经为你分配好了所有情报工作人员，您将会根据这些情报制定战略，然后部署下一步行动。<br>Store：嗯，很好。<br><img src="https://img.alicdn.com/tps/TB1f46CNVXXXXX9XFXXXXXXXXXX-241-193.png" alt="Alt text"></p>
</blockquote>
<p>好了，角色分配完毕，接下来我们如何上演呢？</p>
<p><img src="https://img.alicdn.com/tps/TB1NzjHNVXXXXa6XpXXXXXXXXXX-1399-581.png" alt="Alt text"></p>
<p>相信大家看了上图一(yi)定(lian)知(meng)道(bi)redux数据是如何流动了吧。<br>好了，不扯淡了，我们来看看正版的Redux数据流图是怎么样的吧。</p>
<p><img src="https://img.alicdn.com/tps/TB1tRDBNVXXXXX9XFXXXXXXXXXX-799-391.png" alt="Alt text"></p>
<ol>
<li>View触发dispatch</li>
<li>进入reducer，修改store中的state</li>
<li>将新的state和props传入handleChange中，生成更符合页面的props</li>
<li>传给原始根节点重新render</li>
</ol>
<p>有没有觉得还是上面的图比较形象？哈哈<br>好了，回到正题，既然Redux如此复杂，为啥还需要使用Redux？</p>
<p>我认为Redux的优点：</p>
<ol>
<li>Redux把流程规范了，统一渲染根节点虽然对代码管理上规范了一些,只要有需要显示数据的组件，当相关数据更新时都会自动进行更新。</li>
<li>减少手动编码量，提高编码效率。</li>
<li>Redux 会更加注重数据的单一流向性，所有的 Component </li>
</ol>
<p>都能变的沒有state，还有可以保留Store的历史、回放、修改、以后端进行完全同步等等，同时与后端做<strong>同构</strong>也是相当好的选择。<br>Redux 让程序只拥有一个Listener，不需要在每一个组件中进行自己的state管理，一切所需的数据都从上游作为<strong>props</strong>传进來了。</p>
<p>Redux的缺点：<br>学习成本比较高，严格的函数式思维比较难以转化，刚开始接触会觉得过程非常繁琐。</p>
<p>其实就像那篇文章里说的</p>
<blockquote>
<p>Redux库 它本身只是一系列的助手将 reducers “挂载”到全局唯一的 store 对象上。你可以根据你的喜好来选择是尽可能少，或尽可能多得使用 Redux。</p>
</blockquote>
<p>关于Redux如何使用？请听下回分解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章我只介绍3个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是Redux？&lt;/li&gt;
&lt;li&gt;为什么是Redux？&lt;/li&gt;
&lt;li&gt;Redux如何使用？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##什么是Redux?&lt;br&gt;你们可以看看官网的解释，&lt;br&gt;但是呢，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1JuYfNVXXXXbmaXXXXXXXXXXX-801-259.jpg&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;p&gt;我想没有接触过的人一看肯定一脸懵逼。&lt;br&gt;那么什么是Redux呢？&lt;br&gt;一句话概括，&lt;strong&gt;redux只是一个实现了Flux思想的数据流框架。&lt;/strong&gt;&lt;br&gt;既然是一个数据流框架，那么数据是如何流动的？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1kYfaNVXXXXcLaXXXXXXXXXXX-604-352.png&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="https://alisec-ued.github.io/tags/React/"/>
    
  </entry>
  
</feed>
