<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 使用Webpack打包时的“多页”实践 · Hexo</title><meta name="description" content="使用Webpack打包时的“多页”实践 - alisec-ued"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://alisec-ued.github.io/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/alisec-ued" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">使用Webpack打包时的“多页”实践</h1><div class="post-info">Dec 13, 2016</div><div class="post-content"><h2 id="Webpack在”多页“开发中遇到的问题"><a href="#Webpack在”多页“开发中遇到的问题" class="headerlink" title="Webpack在”多页“开发中遇到的问题"></a>Webpack在”多页“开发中遇到的问题</h2><p>在开发时我们经常使用Webpack官方提供的<code>webpack-dev-server</code>插件。我们只需要通过一个入口<code>main.js</code>和入口页面HTML，用<code>webpack-dev-server</code>就能够提供热更新“Live Reload”以及热替换“Hot Module Replacement”（即HMR） ，这很方便，但是在实际项目中我们遇到了更复杂的场景。 </p>
<p>举例来说，我们现在的一个项目中不仅仅只是一个SPA应用了，它可能是由多个SPA应用构成的一个项目，每个SPA应用可能会由不同的人维护。因此它会有<strong>多个入口JS和入口HTML</strong>。由于没有提供唯一的入口js和html，仅仅使用<code>webpack-dev-server</code>的方案就行不通了。对于这种”多页应用“的项目，最好的方案是在开发时能通过路由切换到对应的SPA应用下，即对应的入口JS和HTML下，为此我们需要一些小技巧。</p>
<a id="more"></a>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>其实在使用Webpack以前其实我们不会有这种烦恼，也许这就是“螺旋式上升”的必经之路。总之，我一开始能想到的方案有以下三种。</p>
<ol>
<li>在开发模式下通过Gulp监听文件变化，然后直接使用Webpack打包出文件，用Gulp-Server处理路由。</li>
<li>任然使用webpack-dev-server，通过proxy代理另一个Server处理路由。</li>
<li>只起一个Server + WebpackMiddleware 在保留热更新和热替换的基础上，增加多路由。</li>
</ol>
<p>三种方法各有利弊。在此我们选择第三种方式，通过独立Server我们能够更方便的处理Mock中Post请求以及Prox等问题，自由度更大。</p>
<p><img src="https://img.alicdn.com/tps/TB1rSsdOFXXXXbiXpXXXXXXXXXX-1026-598.png" alt="server.png"><br>图片中的<code>multientry-dev-server</code>就是接下来我们要创造的server。</p>
<h2 id="Webpack-Dev-Hot-Middleware"><a href="#Webpack-Dev-Hot-Middleware" class="headerlink" title="Webpack Dev\Hot Middleware"></a>Webpack Dev\Hot Middleware</h2><p>官方提供的<code>webpack-dev-server</code>也只是一个用Express起的Server而已，其中使用了<code>webpack-dev-middleware</code> 和 <code>webpack-hot-middleware</code>作为中间件提供<code>Hot Module Replacement/Hot Reloading</code>能力。Webpack Hot Middleware 必须要搭配Webpack Dev Middleware才能使用，因此同样的我们也可以用Express启动一个有热替换功能的服务器，<code>webpack-dev-server</code>只是做了一个简单的封装而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> webpackMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</div><div class="line"><span class="keyword">var</span> webpackHotMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>);</div></pre></td></tr></table></figure>
<p>通过下面的代码建立Webpack的实例以及使用中间件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = express();</div><div class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig);</div><div class="line"><span class="keyword">var</span> middleware = webpackMiddleware(compiler, &#123;</div><div class="line">  <span class="attr">publicPath</span>: webpackConfig.output.publicPath</div><div class="line">&#125;);</div><div class="line">app.use(middleware);</div><div class="line">app.use(webpackHotMiddleware(compiler));</div></pre></td></tr></table></figure></p>
<h2 id="通过路由获取内存中的Webapck打包文件"><a href="#通过路由获取内存中的Webapck打包文件" class="headerlink" title="通过路由获取内存中的Webapck打包文件"></a>通过路由获取内存中的Webapck打包文件</h2><p>使用webpack中间件打包并不会真正的生成文件，它会把文件载入到内存中。<br>为了能通过路由指定跳转到对应的入口JS和HTML，我们在需在项目中做一些约定。假设项目入口为<code>apps</code>目录，该目录下的每一个子目录对应一个SPA应用，在子目录中需要通过一个<code>package.json</code>指定该SPA应用的入口JS和这个SPA应用的其他信息，比如名字和子应用负责人等。<br><img src="https://img.alicdn.com/tps/TB1svDMOFXXXXXbapXXXXXXXXXX-753-497.png" alt="基础模板1.png"><br>package.json文件格式类似如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"app1"</span>,</div><div class="line">  <span class="attr">"main"</span>: <span class="string">"./main.js"</span>,</div><div class="line">  <span class="attr">"author"</span>: <span class="string">"左伦"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>middleware提供了<code>middleware.fileSystem.readFileSync</code>方法读取内存中的文件，文件的地址就是在webpack中配置的输出地址。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/:appName'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> htmlPath = path.join(__dirname, webpackConfig.output.path + req.params.appName + <span class="string">'/index.html'</span>);</div><div class="line">  <span class="built_in">console</span>.log(htmlPath);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    result = middleware.fileSystem</div><div class="line">      .readFileSync(htmlPath);</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    result = err.toString();</div><div class="line">  &#125;</div><div class="line">  res.write(result);</div><div class="line">  res.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>OK, 至此便可以通过路由指定到对应App的入口。</p>
<h2 id="Mock数据以及“首页”"><a href="#Mock数据以及“首页”" class="headerlink" title="Mock数据以及“首页”"></a>Mock数据以及“首页”</h2><p>由于是独立启动的Server，我们可以很方便的在Server中指定任意目录作为我们的静态目录，同时处理好对应的Post请求。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 静态资源，Mock GET请求</span></div><div class="line">app.use(express.static(path.join(__dirname, <span class="string">'../'</span>)));</div><div class="line"><span class="comment">// Mock POST请求</span></div><div class="line">app.post(<span class="string">'/api/*'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.sendFile(path.join(__dirname, <span class="string">'../api'</span>, req.params[<span class="number">0</span>]));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>当越来越多的子App在项目中后，通过手动在浏览器中输入路由再进行跳转会显得十分麻烦。因此可以在Server中新增一个“首页”，列出当前项目下的所有子应用以及开发时的对应路由，具体实现并不难，通过遍历目录下每个应用中的Packge.json即可，最后效果如下:<br><img src="https://img.alicdn.com/tps/TB1pwkrOFXXXXbuXXXXXXXXXXXX-840-562.jpg" alt="屏幕快照 2016-12-11 下午7.11.20.png"><br>终于不用每次在浏览器中敲地址了..<br>到目前为止，已经成功解决了Webpack在“多页“应用下的开发问题，接下来是时候更进一步了。</p>
<h2 id="使用target指定入口应用"><a href="#使用target指定入口应用" class="headerlink" title="使用target指定入口应用"></a>使用<code>target</code>指定入口应用</h2><p>之前说到Webpack中间件在构建时会把文件都读取到内存中，但是当我们的项目越来越大的时候，项目下会有越来越多的子应用，这就造成了另一问题。有时我们只是在开发某一个子App下的代码，但是Webpack每次都会把整个项目打包进内存，非常浪费资源。因此这里我们可以在webpack的配置文件中做点文章，想办法只打包我们需要的目录下的JS。</p>
<p>在执行<code>npm start</code>的时候，通过在命令行里用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">target=appName1,appName2 npm start</div></pre></td></tr></table></figure></p>
<p>其中appName为你想要启动的应用名称（名称在package.json中定义），此时Webpack配置中的Entry只会包含target指定应用名下的入口JS和HTML，大大缩短了Webpack启动时间并且减少了内存占用。这个想法最初是在团队的另一位师兄的代码中看到的，十分巧妙，关键代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> targetEntries = process.env.target;</div><div class="line">targetEntries = targetEntries ? targetEntries.split(<span class="string">','</span>) : <span class="string">''</span>;</div><div class="line">  targetEntries.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'应用: '</span>, value);</div><div class="line">    entryPath = path.join(viewsDir, value);</div><div class="line">    entryJson = fse.readJsonSync(path.join(entryPath, <span class="string">'/package.json'</span>));</div><div class="line">    entryMap[value] = [path.resolve(path.join(entryPath, entryJson.main))];</div><div class="line">    <span class="keyword">var</span> appName = entryJson.name;</div><div class="line">    <span class="keyword">var</span> tplPath = path.join(entryPath, <span class="string">'/index.html'</span>);</div><div class="line">    <span class="keyword">var</span> conf = &#123;</div><div class="line">      <span class="attr">template</span>: tplPath,</div><div class="line">      <span class="attr">filename</span>: path.join(appName, <span class="string">'index.html'</span>),</div><div class="line">      <span class="attr">inject</span>: <span class="string">'body'</span>,</div><div class="line">      <span class="attr">chunks</span>: [appName]</div><div class="line">    &#125;;</div><div class="line">    htmlPluginsArr.push(<span class="keyword">new</span> HtmlWebpackPlugin(conf));</div><div class="line">  &#125;);</div><div class="line">  _.extend(webpackConfig, &#123;</div><div class="line">    <span class="attr">entry</span>: entryMap,</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">      <span class="attr">path</span>: path.join(__dirname, <span class="string">'../build/'</span>),</div><div class="line">      <span class="attr">filename</span>: <span class="string">'[name]/[name].min.js'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">plugins</span>: [</div><div class="line">      <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name]/[name].css'</span>),</div><div class="line">      <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">        <span class="attr">compress</span>: &#123;</div><div class="line">          <span class="attr">warnings</span>: <span class="literal">false</span>,</div><div class="line">          <span class="attr">drop_console</span>: <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    ].concat(htmlPluginsArr)</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>通过这样一个简单的服务，我们完全不用再使用Webpack-Dev-Server了，甚至我们也可以封装成一个相似的plugin。整个问题的思路和解决方案到此为止咯，如果大家有更好的想法可以补充。</p>
<p>文章首发于<a href="https://alisec-ued.github.io/2016/12/13/%E4%BD%BF%E7%94%A8Webpack%E6%89%93%E5%8C%85%E6%97%B6%E7%9A%84%E2%80%9C%E5%A4%9A%E9%A1%B5%E2%80%9D%E5%AE%9E%E8%B7%B5/">alisec-ued</a> ，个人博客<a href="http://http.jolyon.cc" target="_blank" rel="external">地址</a>。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/12/07/前后端渲染模板一致性的思考/" class="next">NEXT</a></div><style>.ds-powered-by, .ds-comments-tab-weibo {
    display: none !important;
}</style><div data-thread-key="2016/12/13/使用Webpack打包时的“多页”实践/" data-title="使用Webpack打包时的“多页”实践" data-url="https://alisec-ued.github.io/2016/12/13/使用Webpack打包时的“多页”实践/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"alisec-ued"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="https://alisec-ued.github.io">alisec-ued</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>var _hmt = _hmt || []; (function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?f356a2d337ba7259fc3c8223ad3deeac";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>