<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 前后端渲染模板一致性的思考 · Hexo</title><meta name="description" content="前后端渲染模板一致性的思考 - alisec-ued"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://alisec-ued.github.io/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/alisec-ued" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">前后端渲染模板一致性的思考</h1><div class="post-info">Dec 7, 2016</div><div class="post-content"><h4 id="一般情况下，前后端合作模式是这样："><a href="#一般情况下，前后端合作模式是这样：" class="headerlink" title="一般情况下，前后端合作模式是这样："></a>一般情况下，前后端合作模式是这样：</h4><ul>
<li>前端负责把设计稿实现成静态的页面demo，并且把一些资源部署到CDN；</li>
<li>后端同学将静态demo修改成后端模板（如<code>vm</code>、<code>xtpl</code>、<code>jade</code>、<code>ejs</code>等）。<br>这里有一个很明显的耦合问题：<br>前后端使用的模板不一致了，导致后期维护成本巨大。由于在模板中可能嵌入了很多业务逻辑，当其他同学来接手项目时，往往容易在不完全理解业务逻辑的情况改出<code>bug</code>。这个在我接触的项目中有活生生的例子。</li>
</ul>
<p>为了提高项目后期可维护性，应该降低这种耦合性，后端同学应该直接使用模板，而不需要通过修改<code>html</code>文件来创建模板。</p>
<h5 id="当然这样又会有两个问题："><a href="#当然这样又会有两个问题：" class="headerlink" title="当然这样又会有两个问题："></a>当然这样又会有两个问题：</h5><ul>
<li>一是前端工作量增大</li>
<li>二是开发约定更为严格。</li>
</ul>
<a id="more"></a>
<p>这两个问题对于前期来说是比较痛苦的，但是随着这种模式的推进，后面会变得越来越容易实现。</p>
<p>当然你可能会说，前后端分离的项目就不存在这种情况。简单的前后端分离项目，因为<code>view层</code>渲染还是由前端来做，并不会出现这种情况。但对于复杂的前后端分离项目，所有引用资源都是在<code>CDN</code>上的，<code>CDN</code>部署是页面完成时直接部署，此外如果中间层数据量大的话（进而导致工作量大），静态页面也可能不是同一人来写。这样问题又回到了一般的前后端合作模式。</p>
<p>于是，使用前后端模板渲染保持一致就是一种解决方案了，这里利用<code>webpack</code>来搭建这样的开发模式。</p>
<h4 id="目前想到的方案大致分为两种（使用xtpl模板引擎）："><a href="#目前想到的方案大致分为两种（使用xtpl模板引擎）：" class="headerlink" title="目前想到的方案大致分为两种（使用xtpl模板引擎）："></a>目前想到的方案大致分为两种（使用<code>xtpl</code>模板引擎）：</h4><ul>
<li>结合<code>html-webpack-plugin</code>插件的template配置参数，编写符合需求的xtpl模板loader；</li>
<li>从内存中获取入口<code>xtpl</code>文件（已经过<code>html-webpack-plugin</code>处理），再通过其映射关系从硬盘中读取其他模板文件。</li>
</ul>
<p>对于第一种方案，你也许会有疑问，<code>template</code>参数不是支持<code>loader</code>加载吗？先来看看这种情况：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// ./extend.xtpl</div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>extend<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">&#123;&#123;&#123;block ('body')&#125;&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line">// ./index.xtpl</div><div class="line">&#123;&#123;extend ('./extend.xtpl')&#125;&#125;</div><div class="line">&#123;&#123;#block ('body')&#125;&#125;</div><div class="line">title: &#123;&#123;title&#125;&#125;</div><div class="line">&#123;&#123;test&#125;&#125;jlk</div><div class="line">&#123;&#123;include ('./content.xtpl')&#125;&#125;</div><div class="line">&#123;&#123;/block&#125;&#125;</div><div class="line"></div><div class="line">// ./content.xtpl</div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当<code>html-webpack-plugin</code>载入<code>index.xtpl</code>文件时，<code>xtpl-loader</code>并没有解析<code>./content.xtpl</code>这个文件，而是返回一个含有<code>require</code>语法的<code>function</code>模板函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// xtpl-loader模块部分代码</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> webpackRemainingChain = loaderUtils.getRemainingRequest(<span class="keyword">this</span>).split(<span class="string">'!'</span>);</div><div class="line">  <span class="keyword">var</span> filename = webpackRemainingChain[webpackRemainingChain.length - <span class="number">1</span>];</div><div class="line">  <span class="keyword">var</span> result = xtemplateCompiler.compileToStr(&#123;</div><div class="line">    <span class="attr">name</span>: filename,</div><div class="line">    <span class="attr">isModule</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">withSuffix</span>:<span class="string">'xtpl'</span>,</div><div class="line">    <span class="attr">content</span>: source,</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">this</span>.cacheable();</div><div class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, <span class="string">`module.exports = <span class="subst">$&#123;result&#125;</span>`</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// xtpl-loader返回的数据result字串，此时的require语法是webpack里的require函数</span></div><div class="line"><span class="comment">// ...code</span></div><div class="line">buffer = root.includeModule(scope, &#123;  <span class="attr">params</span>: [ <span class="built_in">require</span>(<span class="string">"./content.xtpl"</span>) ] &#125;, buffer,tpl);</div><div class="line"><span class="comment">// ...code</span></div></pre></td></tr></table></figure>
<p>当我们使用<code>express</code>服务器渲染这个模板时，并不能正确解析<code>./contetn.xtpl</code>这个文件。当然，正是这个问题我们才有了方案一。</p>
<h4 id="现在让我们来开始尝试"><a href="#现在让我们来开始尝试" class="headerlink" title="现在让我们来开始尝试"></a>现在让我们来开始尝试</h4><p>1、结合html-webpack-plugin插件的template配置参数，编写符合需求的xtpl模板loader<br>这里又分为2中方式：</p>
<ul>
<li>写loader，解析include、extend等模板拼接语法<br>这个工作量和困难度都很大，并且对于不同模板还需要不同实现，所以直接舍弃。</li>
<li>在loader里将所有数据与模板渲染完成，由loader直接返回一个渲染好的字符串，再由express服务器把字符串直接输出到浏览器。</li>
</ul>
<p><code>xtpl-compiler-loader</code>自己编写的<code>laoder</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xtpl = <span class="built_in">require</span>(<span class="string">'xtpl'</span>);</div><div class="line"><span class="keyword">var</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.cacheable();</div><div class="line">  <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</div><div class="line">  <span class="keyword">var</span> webpackRemainingChain = loaderUtils.getRemainingRequest(<span class="keyword">this</span>).split(<span class="string">'!'</span>);</div><div class="line">  <span class="keyword">var</span> temp = webpackRemainingChain[webpackRemainingChain.length - <span class="number">1</span>].split(<span class="string">'?'</span>);</div><div class="line">  <span class="keyword">var</span> filename = temp[<span class="number">0</span>];</div><div class="line">  <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(temp[<span class="number">1</span>].split(<span class="string">'='</span>)[<span class="number">1</span>]);</div><div class="line">  xtpl.renderFile(filename, &#123;<span class="attr">title</span>: <span class="string">'fdsa'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e, content</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(e,content);</div><div class="line">    callback(<span class="literal">null</span>, content);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>html-webpack-plugin</code>配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> htmlWebpackPlugin(&#123;</div><div class="line">  <span class="comment">// ...option</span></div><div class="line">  template: <span class="string">'xtpl-compiler-loader!'</span> + filePath + <span class="string">'?data=&#123;"title": "title"&#125;'</span>,</div><div class="line">  <span class="comment">// ...option</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>express</code>服务器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack编译器</span></div><div class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig);</div><div class="line"></div><div class="line"><span class="comment">// webpack-dev-server中间件</span></div><div class="line"><span class="keyword">var</span> devMiddleware = WebpackDevMiddleware(compiler, &#123;</div><div class="line">  <span class="attr">publicPath</span>: webpackConfig.output.publicPath,</div><div class="line">  <span class="attr">stats</span>: &#123;</div><div class="line">    <span class="attr">colors</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">chunks</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line">app.use(devMiddleware);</div><div class="line">app.use(webpackHotMiddleware(compiler));</div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> filePath = compiler.outputPath; <span class="comment">// loader输出的内存文件目录</span></div><div class="line">  <span class="keyword">var</span> fileContent = devMiddleware.fileSystem.readFileSync(filePath).toString();</div><div class="line">  res.set(<span class="string">'content-type'</span>, <span class="string">'text/html'</span>);</div><div class="line">  res.send(fileContent);</div><div class="line">  res.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>经过上面的配置后，webpack能正确解析模板的i<code>nclude</code>、<code>extend</code>等语法，但是有2个槽点：<br>第一：无法实时监听当子模板的修改；<br>第二：在<code>template</code>参数传入data数据很奇怪，容易让人困惑。<br>因为槽点一，放弃了这个方案。</p>
<p>2、从内存中获取入口<code>xtpl文件</code>（已经过<code>html-webpack-plugin</code>注入处理），再通过其映射关系从硬盘中读取其他模板文件。<br>这种方式在逻辑上完全没有问题（而且不用自己写loader），因为只有一个文件是存储在内存中，而其他文件都是通过映射关系实时从硬盘中读取。</p>
<p><code>html-webpack-plugin</code>配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 字符串方式读取文件</span></div><div class="line"><span class="keyword">new</span> htmlWebpackPlugin(&#123;</div><div class="line">  <span class="comment">// ...option</span></div><div class="line">  template: filePath + <span class="string">'?variable=data'</span>,</div><div class="line">  <span class="comment">// ...option</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>express</code>服务器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack编译器</span></div><div class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig);</div><div class="line"></div><div class="line"><span class="comment">// webpack-dev-server中间件</span></div><div class="line"><span class="keyword">var</span> devMiddleware = WebpackDevMiddleware(compiler, &#123;</div><div class="line">  <span class="attr">publicPath</span>: webpackConfig.output.publicPath,</div><div class="line">  <span class="attr">stats</span>: &#123;</div><div class="line">    <span class="attr">colors</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">chunks</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> filePath = compiler.outputPath;</div><div class="line">  <span class="keyword">var</span> fileContent = devMiddleware.fileSystem.readFileSync(filePath).toString();</div><div class="line"></div><div class="line">  <span class="comment">// truePath是指filePath内存文件路径匹配的硬盘路径</span></div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> xtemplate(fileContent, &#123;</div><div class="line">    <span class="attr">name</span>: truePath,</div><div class="line">    <span class="attr">loader</span>: xtpl.loader,</div><div class="line">    <span class="attr">extname</span>: <span class="string">'xtpl'</span>,</div><div class="line">    <span class="attr">encoding</span>: <span class="string">'utf-8'</span></div><div class="line">  &#125;).render(fse.readJsonSync(config.jsonUrl));</div><div class="line">  res.set(<span class="string">'content-type'</span>, <span class="string">'text/html'</span>);</div><div class="line">  res.send(result);</div><div class="line">  res.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>存在问题：<br>因为直接拿内存中的字符串进行模板渲染，如果模板中含有include、extend等语法，这些包含与继承的相对路径并没有一个路径基准，所以必须手动指定一个路径基准，在<code>vm</code>模板引擎中与有参数可以设置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Engine = <span class="built_in">require</span>(<span class="string">'velocity'</span>).Engine;</div><div class="line"><span class="keyword">new</span> Engine(&#123;<span class="attr">template</span>: content, <span class="attr">root</span>: rootPath);</div></pre></td></tr></table></figure></p>
<p>但在使用<code>xtpl</code>模板存在的问题：<br>第一：<code>xtpl</code>提供的配置参数中并没有类似<code>root</code>参数；<br>第二：<code>xtpl.loader</code>函数并没有被模块<code>xtpl</code>暴露出来，<a href="https://github.com/xtemplate/xtpl/blob/master/lib/xtpl.js" target="_blank" rel="external">点这里看源码</a>。</p>
<p>最后阅读了<code>xtpl</code>源码，从代码调用栈中发现，子模板路径都是相对于父模板路径，而且指定<code>name</code>参数就是父模板的路径。这里解决了第一个问题。<br>第二个问题是由于<code>XTemplate</code>里没有显式的给出<code>loader</code>，<code>loader</code>是模板的加载器，见<a href="https://github.com/xtemplate/xtpl/blob/master/lib/xtpl.js#L130" target="_blank" rel="external">这里</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> loader = &#123;</div><div class="line">    <span class="attr">load</span>: <span class="function"><span class="keyword">function</span> (<span class="params">tpl, callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> template = tpl.root;</div><div class="line">        <span class="keyword">var</span> path = tpl.name;</div><div class="line">        <span class="keyword">var</span> rootConfig = template.config;</div><div class="line">        <span class="keyword">var</span> extname = rootConfig.extname;</div><div class="line">        <span class="keyword">var</span> pathExtName;</div><div class="line">        <span class="keyword">if</span> (endsWith(path, extname)) &#123;</div><div class="line">            pathExtName = extname;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            pathExtName = Path.extname(path);</div><div class="line">            <span class="keyword">if</span> (!pathExtName) &#123;</div><div class="line">                pathExtName = extname;</div><div class="line">                path += pathExtName;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (pathExtName !== extname) &#123;</div><div class="line">            readFile(path, rootConfig, callback);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            getTplFn(template, path, rootConfig, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>因为模块中没有暴露出<code>loader</code>接口，所以要解决第二个问题只能自己写一个<code>npm</code>包来实现<code>loader</code>的功能。</p>
<p>当前的开发模式采用的是第二种模式，因为实现起来更容易，逻辑也更清晰，功能也完善。</p>
<p>欢迎补充！~~~</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/12/02/flex布局/" class="next">NEXT</a></div><style>.ds-powered-by, .ds-comments-tab-weibo {
    display: none !important;
}</style><div data-thread-key="2016/12/07/前后端渲染模板一致性的思考/" data-title="前后端渲染模板一致性的思考" data-url="https://alisec-ued.github.io/2016/12/07/前后端渲染模板一致性的思考/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"alisec-ued"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="https://alisec-ued.github.io">alisec-ued</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>var _hmt = _hmt || []; (function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?f356a2d337ba7259fc3c8223ad3deeac";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>